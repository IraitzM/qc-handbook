[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantum Computing Handbook",
    "section": "",
    "text": "Preface\nYou may wonder, another book about Quantum Computing? Well, by telling it from a different perspective it may help people coming from different fields (meaning, non-physicists) grasp the idea behind quantum computing. This is also a work for myself, as it will definitely help me better understand some of the concepts. Just by explaining things I found it is the best way to challenge ones knowledge about a field you are trying to master.\nAlso, it costs nothing so, no harm done. Code snippets are easier to maintain so hopefully, everything will work with the latest versions. I hope you enjoy reading it as much as I have learned creating it.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Quantum Computing Handbook",
    "section": "About me",
    "text": "About me\nMi name is Iraitz Montalb√°n, Computer Scientist by background, I started in the field of Quantum Computing by chance, while doing an internship in 2010 there were some guys doing something called quantum computing, which was a mathematical framework back then. I kept my interest in the field and ended up doing a masters on Quantum Computing Technologies at UPM and working with some startups in the field.\nFill free to keep in touch.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Well, quantum computing. Really trendy topic. Although it is not the only unconventional computing paradigm out there:\n\nQuantum Computing\nNeuromorphic computing\nAnalog computing\nProbabilistic computing\nThermodynamic computing\nBiological computing\n\nFancy as it might be there are some really cool things we can learn from trying to challenge the status quo. It is not the first paradigm aiming to dethrone classical computing - yes, we will need to do that distinction from now on - but it is certainly the one that has progressed the most. We do have quantum computers, computers the open public can use and that are already fighting in some critical areas making people nervous about it.\nLet‚Äôs see if we can get our heads around what quantum computing is and how to work with it. Let‚Äôs start üéâ",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "parts/gettingstarted/qc-intro.html",
    "href": "parts/gettingstarted/qc-intro.html",
    "title": "Getting started",
    "section": "",
    "text": "What is quantum computing? Well, nothing but a new paradigm to perform computation. It is based on the formalism of quantum physics and even though it might be challenging to grasp at first, just some basic linear algebra might help you understanding the basics. I will try to show it by examples in Python so that it is less challenging and more hands-on.\nClassical computing also embraces physics but at a much higher abstraction level. By being able to manipulate electricity the first devices, analog devices, were able to perform first algorithms. Programming analog devices it is definitely a challenging task, so operation digitization was able to ease that task also making easier for machines to interoperate given that even though different manufacturers where involved, by adopting the same standards in terms of digital operations (time-bounded actions) it made it a lot easier to understand each other.\nBoolean algebra made this possible, providing an universal set of operations to produce the algorithms we do use on a daily basis. Being able to manufacture bits as voltages made possible to build machines capable of following that algebra and abstracting it further to higher level programming languages. The rest is history.\nThe main idea behind quantum computing is that, instead of working at a macroscopic level as we are used to, by using quantum states on some physical mean we could benefit from the effects inherent to quantum physics to perform computation in different ways. By leveraging the those effects some really complex calculations could be performed more efficiently. Don‚Äôt worry, we will be using higher level programming languages as well but we need to understand what is going on under the hood.\nSuperposition, interference and entanglement are the key to most of the speedups claimed in the literature, and we will try to understand how we can work with those in order to produce algorithms for optimization or machine learning tasks.\nHere goes a little roadmap on what has happened in the field in the last two decades:\n\n\n\n\nQC timeline\n\n\n\nThere are plenty of good references on the basic stuff so we will try to link those as well as we cover some specifics around optimization and machine learning more in detail. But let‚Äôs start with the basics: quantum states and qubits.",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "parts/gettingstarted/basics.html",
    "href": "parts/gettingstarted/basics.html",
    "title": "Basics",
    "section": "",
    "text": "Qubits\nThe main concept leveraged by quantum computers is the ability to act over quantum states. A quantum state is no other thing than a mathematical description of the probability distribution for the potential outcome after performing a measurement upon a system. It sounds tricky but it is simpler than it sounds, bare with me.\nThink about quantum states as a normed vector (vector of length 1). Let‚Äôs try with the most basic one, a system of a single unit state. The quantum version of a coin looks like:\n\\[\n|\\phi\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\n\\]\nbeing this the minimum representation of a quantum state: a unit norm vector \\(\\in \\mathbb{C}^2\\) whose physical realization is known as the qubit.\nIt represents the two extremes the system can be at and their probability amplitudes. It means we will observe one or the other if we observe the system and those probabilities must add up to one - \\(|\\alpha|^2+|\\beta|^2 = 1\\) - given that there is certainty that the system exists and we can observe it.\nThis state can be decomposed into basic components, basis states. This is relevant as when it comes to quantum computers, our minimal unit will be expressed on its computational basis: \\[\n|0\\rangle = \\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right]\n\\quad\n|1\\rangle = \\left[\n\\begin{array}{c}\n0 \\\\\n1\n\\end{array}\n\\right]\n\\]\nWe use this simplified Dirac notation just to make it shorter to write, otherwise we will take much of the space writing vectors an matrices. It is funny because those two column vectors will be translated to the already known 0 and 1 bit when we read the state from a classical computer. Classical computers only work with bits so no matter what we do at a quantum level, everything will be then reduced to a set of 0s and 1s. But we will deal with this later when we talk about measurements.\nThus previous state can be described in our qubit unit as:\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right],\n\\]\nmeaning our quantum state‚Äôs potential outcomes are \\(|0\\rangle\\) with probability \\(|\\alpha|^2\\) and \\(|\\beta|^2\\) odds for \\(|1\\rangle\\). How do we know the actual outcome of our state? Well, we need to measure. This is done by projecting it over one of those states, so the complex conjugate of previous vectors can be used for that.\n\\[\n\\langle 0 | = \\left[\n\\begin{array}{cc}\n1 & 0\n\\end{array}\n\\right]\n\\quad\n\\langle 1 | = \\left[\n\\begin{array}{cc}\n0 & 1\n\\end{array}\n\\right]\n\\]\nso by projecting our state into this basis vectors we would obtain:\n\\[\n|\\langle 0 |\\psi\\rangle|^2 = \\left|\\left[\n\\begin{array}{cc}\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\\right|^2 = |\\alpha|^2\n\\]\nSo we don‚Äôt actually evaluate the state, but we use a basis vector to see ‚Äúhow close‚Äù our state is to this state that is part of our basis set.\nAnd here we found one of the first strange things about qubits in comparison to bits. Being 0 and 1 the basic states of a bit, its physical realization can only be in on of those states while qubits can be partially in more than one state creating a superposition of states.",
    "crumbs": [
      "Getting started",
      "Basics"
    ]
  },
  {
    "objectID": "parts/gettingstarted/basics.html#superposition",
    "href": "parts/gettingstarted/basics.html#superposition",
    "title": "Basics",
    "section": "Superposition",
    "text": "Superposition\nThis is one of the trickiest things to get when first approaching quantum computing as it is not so intuitive from our macroscopic perspective. It is also often misunderstood, we will try to make it clear. This is an example of a superposed state\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle.\n\\]\nThe state is a superposed, no question on that, but our ability to perceive it is limited by the measurement procedure itself. We need to project our quantum state into one of the two potential states we can obtain (\\(|0\\rangle\\) or \\(|1\\rangle\\)). Sadly, when measuring only classical bits can be obtained (0 or 1) into our conventional machines, so no probability amplitude, no phase‚Ä¶ information gets lost in the measurement process.\nThe probability histogram is created after a sequence of quantum state creations and measurements we often call SHOTS.\n\n\n\n\nCoin toss\n\n\n\nFor a series of measurements we have seen \\(|0\\rangle\\) state 50.6% and \\(|1\\rangle\\) state 49.4%. Definitely, looks superposed to me. It is hardly perceived in the classical regime were every basis state will be interpreted as its complementary classical bit, but quantum state holds a lot of information more than this simple binary choice.\nIn fact, both \\(\\alpha\\) and \\(\\beta\\) are complex numbers, that is why bloch sphere renders a more in detail expression of the state of a qubit. Sadly for us this is something we will never perceive from a real device but helps while building the formalism or creating algorithms.\n\n\n\n\nBloch sphere\n\n\n\nQuantum states can therefore be expressed also as:\n\\[\n|\\phi\\rangle = \\cos (\\theta/2) |0\\rangle + e^{i\\phi} \\sin (\\theta/2)|1\\rangle\n\\]\nwhich represents the sphere coordinates on the surface of the bloch sphere. It is more evident in this case that rendering simple bits will actually remove most of the information contained in the states when operating with them in the quantum regime.",
    "crumbs": [
      "Getting started",
      "Basics"
    ]
  },
  {
    "objectID": "parts/gettingstarted/basics.html#measurement",
    "href": "parts/gettingstarted/basics.html#measurement",
    "title": "Basics",
    "section": "Measurement",
    "text": "Measurement\nMeasuring quantum states is a necessary condition to extract information out of it, but by doing so we affect the system due to the collapse of the wave function. I know, too technical.\nOk, so when we observe a quantum state we can only see one of the potential outcomes, the one we observe actualy. And this affects the system, meaning when we look at it it collapses to the state we have observed and no longer exsits as a probability ditribution but as a certainty.\nThe action we use to observe the quantum state is by means of Observables (self-adjoint operators). These are used to project the measurement of a given quantum state to one of its eigenvalues. Using the closeness between quantum state and eigenvectors of the observable we can measure what is the overlap between those. The eigenvectors of the observable form an orthonormal basis for the Hilbert space, therefore each measure corresponds to a mapping to the eigenvectors comprising the basis. I know, this is a little bit too technical but just think about the observable as a pair of tinted glasses, if glasses have a green-ish color, everything will look some sort of green: dark green for black or light green for white. It is kind of like that. Kind of.\nWe will see that a common observable used is the Pauli \\(\\sigma_z\\) matrix\n\\[\n\\sigma_z = \\left[\n\\begin{array}{cc}\n1 & 0 \\\\\n0 & -1\n\\end{array}\n\\right]\n\\]\nWe can decompose it on its eigenvectors and eigenvalues so that\n\\[\n\\sigma_z|0\\rangle = 1|0\\rangle \\rightarrow \\sigma_z|1\\rangle = -1|1\\rangle.\n\\]\nTherefore, any potential measurement will be mapped to one of those two eigenvectors and its eigenvalue used as the outcome of the measurement. The basis set shown above is often known as the computational basis and it will become relevant when we move to actual implementations.\nFrom our previous state \\(|\\phi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle\\) and perform a measurement over the computational basis (\\(|0\\rangle,|1\\rangle\\)) where evidently the outcome would be \\(|0\\rangle\\) with \\(|\\alpha|^2\\) probability or \\(|1\\rangle\\) with \\(|\\beta|^2\\) probability. But more importantly, a single measurement, no matter how complex, entangled or superposed our state might be, will only be able to recover classical bits mapping two previously seen states (\\(|0\\rangle \\rightarrow 0\\) and \\(|1\\rangle \\rightarrow 1\\)).\nWhat happens after measurement is performed? Well, that is the trickiest part as the process of measuring obliges to our quantum state to position itself and make a choice. This means our quantum state after measurement will no longer be in a superposition state and will be the outcome of the previous measurement \\(|0\\rangle\\) for the remaining time period.\nIn order to fully grasp the statistics of the state we should find way to reproduce the state and perform enough measurements, so we can characterize its actual condition as much as we can out of the measurement statistics it presents. Measuring in the basis \\(\\{|0\\rangle, |1\\rangle\\}\\) (also called computational basis) may not be enough to capture the actual state. Therefore, a basis change is needed, but we will see that quantum devices only offer computational basis as the measuring basis. That means in certain cases we will need to rotate our qubits so that the basis change is artificially done.\nIf we would like to measure in the \\(\\{|+\\rangle, |-\\rangle\\}\\) basis then a rotation of \\(-\\pi / 2\\) in the Y axis will be needed. \\(\\{|i\\rangle, |-i\\rangle\\}\\) basis will require then a rotation over X axis of \\(\\pi / 2\\). That way we get to shift the reference point and measure according to our target axis.\nNext thing is to operate on those things, let‚Äôs see how gates differ from our knowledge from classical computing.",
    "crumbs": [
      "Getting started",
      "Basics"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html",
    "href": "parts/gettingstarted/gates.html",
    "title": "Quantum gates",
    "section": "",
    "text": "The Hall of Gates\nNow that we know how our states might look like\n\\[\n|\\phi\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\n\\]\nwould be relevant to understand how we can operate on them. Quantum computers, like classical computers, use logical gates to do their work. In this case, gates are operations that take our initial state and convert it into a different quantum state. Classical regime is poor in this sense as allowed changes are only between 0 and 1, but quantum states and qubits allow for much more information to be represented. That makes quantum logical gates also more complex and rich.\n\\[\nU|\\psi\\rangle \\rightarrow |\\phi\\rangle\n\\]\nBut in this case, these gates are specific to the quantum regime. We will find some similarities like in the case of the not gate and some particular cases like the Hadamard gate.\nA quantum gate is a frame to describe the quantum process taking a quantum state at time \\(t\\) to the one at \\(t+1\\). For a closed quantum system the operator that describes the evolution of the system can be described with \\(e^{-i\\int H dt/\\hbar}\\), which is a unitary operator based on the Hamiltonian that describes the dynamics of the system. What is a Hamiltonian you ask? Well, this video may be of interest then:\nJust take into account that, if we ignore the global phase of the quantum state, we can suppose all the quantum gates to be special unitary operations, i.e., the determinant of them is 1. This is so that the obtained state falls into the surface of the bloch sphere (otherwise we enter a much more complex territory).\nAs in classical computing, some key gates need to be known. The \\(NAND\\) being an universal boolean logic gate as it can create all the other options required to render boolean logic, we should introduce some of the core gates when talking about quantum computing and the universality of those gates.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#the-hall-of-gates",
    "href": "parts/gettingstarted/gates.html#the-hall-of-gates",
    "title": "Quantum gates",
    "section": "",
    "text": "NOT-gate (X)\nThe not gate (\\(X\\) as the operator gate and \\(\\sigma_x\\) if expressed as a Pauli matrix) is one of the most basic concepts in computing. A classical operation that takes the bit in a position (0 or 1) to its opposite. But, quantum not extends that basic concept to the complexity of the quantum regime. The operator can be represented by a matrix like the following one:\n\\[\nX = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\n\\]\nThen, the operation \\(X|0\\rangle = |1\\rangle\\) can be validated by the simple multiplication of the matrix of the gate by the quantum state:\n\\[\nX|0\\rangle = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n0 \\\\\n1\n\\end{array}\n\\right] = |1\\rangle\n\\]\nBut if we perform this very simple example with the generic case for \\(|\\psi\\rangle\\)\n\\[\nX|\\psi\\rangle = X(\\alpha|0\\rangle + \\beta |1\\rangle) = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n\\beta \\\\\n\\alpha\n\\end{array}\n\\right] = \\beta|0\\rangle + \\alpha |1\\rangle = |\\phi\\rangle\n\\]\nwe have basically created a new state where its outcome probabilities have been shifted. Therefore, the \\(X\\) operation can be used to shift the state ratter than perform a mere coin flipping. This gets more interesting looking at some specific gates like the Hadamard gate.\n\n\nHadamard (H)\nIts matrix representation is\n\\[\nH = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\n\\]\nAnd its effect‚Ä¶\n\\[\nH|0\\rangle = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{c}\n1 \\\\\n1\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle = |+\\rangle\n\\]\nbasically it allows as to switch the axis of the bloch sphere and work on the superposition of the states on the \\(Z\\) axis.\n\n\n\n\nBloch sphere",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#rotating-quantum-states",
    "href": "parts/gettingstarted/gates.html#rotating-quantum-states",
    "title": "Quantum gates",
    "section": "Rotating quantum states",
    "text": "Rotating quantum states\nIn essence, we will see that many gates what they offer us is simply rotations over the three main axes of the bloch sphere:\n\\[\nR_x(\\theta) = \\left(\n    \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -i\\sin(\\frac{\\theta}{2}) \\\\\n        -i\\sin(\\frac{\\theta}{2}) & \\cos(\\frac{\\theta}{2})\n    \\end{array}\n    \\right)\n\\]\n\\[\nR_y(\\theta) = \\left(\n    \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -\\sin(\\frac{\\theta}{2}) \\\\\n        \\sin(\\frac{\\theta}{2}) & \\cos(\\frac{\\theta}{2})\n    \\end{array}\n    \\right)\n\\]\n\\[\nR_z(\\theta) = \\left(\n    \\begin{array}{cc}\n        e^{-i\\frac{\\theta}{2}} & 0 \\\\\n        0 & e^{i\\frac{\\theta}{2}}\n    \\end{array}\n    \\right)\n\\]\nmaking the general case \\(R_M(\\theta) = \\exp^{(‚àíi\\theta M/2)}\\) where \\(M \\in \\{X,Y,Z\\};\\) being those three the Pauli gates the Pauli matrices \\(\\sigma_x, \\sigma_y \\text{ and } \\sigma_z\\). Actually the literature will quote a more generic case which will be given by the following gate operator\n\\[\nU(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -e^{i\\lambda}\\sin(\\frac{\\theta}{2})\\\\\n        e^{i\\phi}\\sin(\\frac{\\theta}{2}) & e^{i(\\phi+\\lambda)}\\cos(\\frac{\\theta}{2})\n    \\end{array} \\right)\n\\]\nwhich maps to previous gates following the relationship \\(U(\\theta,0,0) = R_y(\\theta)\\), \\(U(0,0,\\lambda) = R_z(\\lambda)\\) and \\(U(\\theta,-\\frac{\\pi}{2},\\frac{\\pi}{2}) = R_x(\\theta)\\)",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#native-gates",
    "href": "parts/gettingstarted/gates.html#native-gates",
    "title": "Quantum gates",
    "section": "Native gates",
    "text": "Native gates\nQuantum Computing is a mathematical framework that allows for all kind of gates to be designed but in many cases depending on the manufacturer of the device the set of gates we can use may differ. We will need to find the combination of gates that will produce our desired action by using the gates each device is equipped with. Also called native gates.\nThe native gate set is the gate set, one and two-qubit gates, that should be used to translate any theoretical operator or action from the mathematical framework to be physical action that can be performed, decomposing the original action into different operations or better expressed, transpiling the circuit.\n\n\n\n\n\n\nYou won‚Äôt believe this but‚Ä¶\n\n\n\n\n\nActually, two of the most basic gates, the Hadamard and CNOT gate, do not exist. We always need to find translations for those fundamental operations when dealing with hardware.\n\n\n\nOur circuit:\n\n\n\n\nSome circuit\n\n\n\n\\(H\\) represents the Hadamard gate and the other two blue ones, the Control-NOT gate as the basis for generating entangled states.\nNo device can implement natively at least to the best of our knowledge. Therefore, in order to apply that gate own needs to apply native gates that produce the same action or unitary matrix.\nWhat can run on IBM devices if we convert it to\n\n\n\n\nTranspiled circuit\n\n\n\nWe will see this in more detail later when we review hardware providers and their actual implementation.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#control-not-cnot",
    "href": "parts/gettingstarted/gates.html#control-not-cnot",
    "title": "Quantum gates",
    "section": "Control-NOT (CNOT)",
    "text": "Control-NOT (CNOT)\nOne interesting gate to be implemented in this regime is the control not or CNOT gate. This acts on the target qubit only if the first qubit is at \\(|1\\rangle\\) state. It does not require any classical measurement or observation, meaning the control qubit still holds its quantumness after gate operation. This is critical to the good functioning of the system otherwise any classical action would affect the quantum state making it purely classical.\n\\[\nCNOT|00\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n1 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{array}\n\\right] = |00\\rangle\n\\]\n\\[\nCNOT|10\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n0 \\\\\n0 \\\\\n1 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n0 \\\\\n0 \\\\\n0 \\\\\n1\n\\end{array}\n\\right] = |11\\rangle\n\\]\nBut what does there happen when it gets applied to a superposed state.\n\\[\nCNOT|+0\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\frac{1}{\\sqrt{2}} \\\\\n0 \\\\\n\\frac{1}{\\sqrt{2}} \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n\\frac{1}{\\sqrt{2}} \\\\\n0 \\\\\n0 \\\\\n\\frac{1}{\\sqrt{2}}\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\n\\]\nQuite interesting. Have you tried decomposing this state into the tensor product of the quantum state of the two qubits?\nIt is fine, because it is not possible. This is what it is called an entangled state. One particular benefit of this states is that by measuring only one of those qubits we know the value of the second one without any need for measurement. We cannot act on one party without affecting the whole system, but we also know the condition of the other party by observing just one. This is what Einstein called spooky actions at a distance and are critical to the scalability of the quantum algorithms.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#entanglement",
    "href": "parts/gettingstarted/gates.html#entanglement",
    "title": "Quantum gates",
    "section": "Entanglement",
    "text": "Entanglement\nEntangled states are critical for some of the quantum algorithms allowing us to outperform (theoretically at least) classical computing. The most basic (and probably best known) entangled states are the Bell states or EPR pairs.\n\\[\n|\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\quad |\\Phi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle - |11\\rangle)\n\\]\n\\[\n|\\Psi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle + |10\\rangle) \\quad |\\Psi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|10\\rangle - |10\\rangle)\n\\]\nEntangled states are behind some of the key algorithms in communication protocols such as Quantum Teleportation or Superdense coding or behind the post-quantum cryptography proposals, like the Quantum Key Distribution. But they are also relevant for computations as we will see in the following sections.\nI know, too much theory. Let‚Äôs try to execute some examples to make it more clear.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html",
    "href": "parts/gettingstarted/simulations.html",
    "title": "1¬† Simulations",
    "section": "",
    "text": "1.1 From scratch\nNow, do we have to create our own set of gates and operations? Well, it might be a good practice as the formalism can be easily reproduced by setting the basic needs:\nWe can then create our own set of functions and objects to simulate those computations:\nWe would easily create basic vector structures for our quantum framework. The minimum unit is the qubit and in order to frame the potential quantum states it may hold we would need to create the computational basis set \\(\\{|0\\rangle, |1\\rangle \\}\\).\nimport numpy as np\nfrom qiskit.visualization import array_to_latex\n\nzero = [[1], [0]]\n\narray_to_latex(array=zero, prefix='|0\\\\rangle = ', max_size=(10,10))\n\n\\[\n|0\\rangle =\n\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\n\\]\none = [[0], [1]]\n\narray_to_latex(array=one, prefix='|1\\\\rangle = ', max_size=(10,10))\n\n\\[\n|1\\rangle =\n\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\n\\]\nNow lets try with some gates.\n\\[\nX = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right] \\quad\nH = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\n\\]\nX = [[0,1],[1,0]]\n\narray_to_latex(array=X, prefix='X = ', max_size=(10,10))\n\n\\[\nX =\n\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\n\\]\nhadamard = np.dot((1/(np.sqrt(2))), [[1, 1], [1, -1]])\n\narray_to_latex(array=hadamard, prefix='H = ', max_size=(10,10))\n\n\\[\nH =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\nWell, it is already taking shape. We can test if the outcome matches our expectations.\nsuperposition = np.dot(hadamard, zero)\n\narray_to_latex(array=superposition, prefix='H|0\\\\rangle = |+\\\\rangle = ', max_size=(10,10))\n\n\\[\nH|0\\rangle = |+\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\none = np.dot(X, zero)\n\narray_to_latex(array=one, prefix='X|0\\\\rangle = |1\\\\rangle = ', max_size=(10,10))\n\n\\[\nX|0\\rangle = |1\\rangle =\n\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\n\\]\nWe can scale it to a couple of qubits to see what we get. Let‚Äôs try to create on of the bell states we saw during class.\n\\[\n|\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\quad |\\Phi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle - |11\\rangle)\n\\] \\[\n|\\Psi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle + |10\\rangle) \\quad |\\Psi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|10\\rangle - |10\\rangle)\n\\]\nWe will need the CNOT gate for this.\nCNOT = [[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]\n\narray_to_latex(array=CNOT, prefix='CNOT = ', max_size=(10,10))\n\n\\[\nCNOT =\n\\begin{bmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 1 & 0 & 0  \\\\\n0 & 0 & 0 & 1  \\\\\n0 & 0 & 1 & 0  \\\\\n\\end{bmatrix}\n\\]\nWith this we will create a two qubit system, apply the Hadamard gate to the first one and the CNOT gate with the conrol over the first qubit as well.\n# Initial state\ninit_state = np.kron(zero, zero)\n\n# (I tensor Hadamard)\nHI = np.kron(hadamard, np.eye(2))\nWith that we can perform the full operation\n\\[\nCNOT (I\\otimes H)|00\\rangle = |\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle\n\\]\npsi_1 = np.dot(HI, init_state)\npsi = np.dot(CNOT, psi_1)\n\narray_to_latex(array=psi, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2}  \\\\\n0  \\\\\n0  \\\\\n\\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\nThere you go. This is our entangled 2-qubit state. Building the whole formalism from scratch might be tedious, but it helps us understand every detail of it.\nOf course, in order to continue forward, we will take advantage of the collective effort and use some existing tools to ease our way into quantum computing.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simulations</span>"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html#qutip",
    "href": "parts/gettingstarted/simulations.html#qutip",
    "title": "1¬† Simulations",
    "section": "1.2 QuTip",
    "text": "1.2 QuTip\nOf course, we are not the first ones with this need, so there do exist some quite useful libraries in this domain. QuTiP might be one of the most used ones (at least for us, Python enthusiasts).\n\nimport scipy\nimport numpy as np\nfrom qutip import Qobj, mesolve\nfrom qutip import basis, tensor\nfrom qutip.qip.operations import cnot\n\n# Basis states\nzero = basis(2,0)\none = basis(2,1)\n\n# |10&gt;\none_zero = tensor(one, zero)\n\n# CNOT\nhamiltonian = cnot().full()\n\n# e^itH\nu_generator = Qobj(1j * scipy.linalg.logm(hamiltonian), dims=[[2] * 2] * 2)\n\n# Time range 0.0 -&gt; 1.0\ntimes = np.arange(0, 1.1, 0.1)\n\n# \\psi = H\\psi_0\nevolution = mesolve(u_generator, one_zero, times)\n\n\nevolution.states[0]\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [0.]\n [1.]\n [0.]]\n\n\n\nevolution.states[1]\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.        +0.j        ]\n [0.        +0.j        ]\n [0.97552824+0.15450855j]\n [0.02447175-0.15450855j]]\n\n\n\nevolution.states[-1]\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.00000000e+00+0.00000000e+00j]\n [0.00000000e+00+0.00000000e+00j]\n [1.07316279e-06+9.88099195e-07j]\n [1.00000000e+00-9.88099195e-07j]]\n\n\nLet‚Äôs go by steps.\n\nfrom qutip import basis, tensor\n\none = basis(2,1)\nzero = basis(2,0)\n\none_zero = tensor(one, zero) # |10&gt;\none_zero\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [0.]\n [1.]\n [0.]]\n\n\n\nfrom qutip.qip.operations import cnot\n\ncnot_matrix = cnot().full()\ncnot_matrix\n\narray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n\n\nIn fact, it allows us to do more than just the simple operations we envisioned. For example, we could generate the whole evolution over a period of time of the \\(U\\) unitary generated for our Hamiltonian.\n\nfrom qutip import identity\nfrom qutip.qip.operations import hadamard_transform\n\n# hamiltonian\nhamiltonian =  cnot() * tensor(hadamard_transform(1), identity(2))\nhamiltonian\n\nQuantum object: dims=[[2, 2], [2, 2]], shape=(4, 4), type='oper', dtype=Dense, isherm=False\nQobj data =\n[[ 0.70710678  0.          0.70710678  0.        ]\n [ 0.          0.70710678  0.          0.70710678]\n [ 0.          0.70710678  0.         -0.70710678]\n [ 0.70710678  0.         -0.70710678  0.        ]]\n\n\n\nimport numpy as np\nimport scipy\nfrom qutip import Qobj, mesolve\n\n# Initial state\ninit_state = tensor(zero, zero) # |00&gt;\n\n# e^itH\nu_generator = Qobj(1j * scipy.linalg.logm(hamiltonian.full()), dims=[[2] * 2] * 2)\n\n# Time range\ntimes = np.arange(0, 1.1, 0.1)\nevolution = mesolve(u_generator, init_state, times)\n\n\nevolution.states[0]\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[1.]\n [0.]\n [0.]\n [0.]]\n\n\n\nevolution.states[1]\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[ 0.99487486+0.02262725j]\n [-0.00204247+0.02262725j]\n [-0.03057749-0.05462701j]\n [ 0.04788161-0.05462701j]]\n\n\n\nevolution.states[-1]\n\nQuantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[ 7.07106734e-01-2.77290944e-08j]\n [-2.74299662e-08-2.77290944e-08j]\n [ 6.61796939e-08+6.69439559e-08j]\n [ 7.07106828e-01+6.69439558e-08j]]\n\n\n\npsi = np.round(evolution.states[-1].full(), decimals = 5)\n\narray_to_latex(array=psi, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n0.70711  \\\\\n0  \\\\\n0  \\\\\n0.70711  \\\\\n\\end{bmatrix}\n\\]\n\n\nLooks like \\(\\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\\) but due to numerical imprecisions we wil get this type of ugly structures in between. We will need to familiarize with those artifacts as noise when using hardware will produce similar numerical artifacts.\nWell, having a theoretical framework may be a good option for simulating and doing some local experimentation but that will reach soon limitations when trying to scale it up. Our classical device won‚Äôt be able to perform the whole system calculations and we might need to switch to actual quantum computers doing those. Therefore, we need to find a way to o so.\nThis is why some manufacturers have invested time and effort on creating open-source frameworks to be adopted by the community (and position themselves). Companies such as IBM or AWS have leveraged their own version that also allows for these programs to be sent to an end device that will perform the set of operations.\n\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2, 2)\nqc.x(0)\nqc.cx(0, 1)\nqc.measure([0,1], [0,1])\n\nqc.draw('latex')",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simulations</span>"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html#qiskit",
    "href": "parts/gettingstarted/simulations.html#qiskit",
    "title": "1¬† Simulations",
    "section": "1.3 Qiskit",
    "text": "1.3 Qiskit\nQiskit is IBM‚Äôs quantum computing toolkit the enables interaction with their devices. Let‚Äôs first start replicating the theoretical basis and then move forward up to device simulation.\nOpflow is the framework section dedicated to provide the pieces to perform previous computations.\n\nfrom qiskit.quantum_info import Statevector\n\nZero = Statevector.from_label('0')\nOne = Statevector.from_label('1')\n\n\nprobs = Zero.probabilities()\nprint('Probability of measuring 0: {}'.format(probs[0]))\n\nProbability of measuring 0: 1.0\n\n\n\nprint('Probability of measuring 1: {}'.format(probs[1]))\n\nProbability of measuring 1: 0.0\n\n\n\nPlus = Statevector.from_label('+')\n\nprint(Plus)\n\nStatevector([0.70710678+0.j, 0.70710678+0.j],\n            dims=(2,))\n\n\n\nPlus.probabilities()\n\narray([0.5, 0.5])\n\n\nQiskit tends to understand everything in terms of circuits. But in essence we can request the actual operation being performed there and check that the Hadamard action over a \\(|0\\rangle\\) state (the initial state) provides the \\(|+\\rangle\\) state as expected.\n\narray_to_latex(array=Plus.data, prefix='|+\\\\rangle = ', max_size=(10,10))\n\n\\[\n|+\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\nWhat would be the outcome of it?\n\nprobs = Plus.probabilities()\nprint('Probability of measuring 0: {}'.format(probs[0]))\n\nProbability of measuring 0: 0.4999999999999999\n\n\nThis is the expected outcome for the \\(\\langle 0 | \\psi \\rangle\\) operation. But we can mimic it as well.\n\nabs(np.dot(Zero.data, Plus.data.T)**2)\n\n0.4999999999999999\n\n\nSimilarly gate operations can be used.\n\nfrom qiskit.quantum_info import Pauli\n\nX = Pauli('X')\n\nAnd what is the amplitude of \\(|1\\rangle\\) after the \\(X|0\\rangle\\) operation?\n\nZero.evolve(X) == One\n\nTrue\n\n\nQiskit orders bits in a specific manner so some gates may look different but is just a matter of ordering when applying the operations.\n\nfrom qiskit.circuit.library import UnitaryGate\n\nmatrix = [[1., 0., 0., 0.],\n          [0., 0., 0., 1.],\n          [0., 0., 1., 0.],\n          [0., 1., 0., 0.]]\nCNOT = UnitaryGate(matrix)\n\nLet play around with the Bell state we produced before\n\\[\nCNOT (I\\otimes H)|00\\rangle = |\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle\n\\]\n\nprint(Zero ^ Zero)\n\nStatevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n            dims=(2, 2))\n\n\n\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2)\nqc.h(0)\n\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê\nq_0: ‚î§ H ‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò\nq_1: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n          \n\n\n\nfrom qiskit.quantum_info import Operator\n\nprint(Operator(qc).data)\n\n[[ 0.70710678+0.j  0.70710678+0.j  0.        +0.j  0.        +0.j]\n [ 0.70710678+0.j -0.70710678+0.j  0.        +0.j  0.        +0.j]\n [ 0.        +0.j  0.        +0.j  0.70710678+0.j  0.70710678+0.j]\n [ 0.        +0.j  0.        +0.j  0.70710678+0.j -0.70710678+0.j]]\n\n\n\n(Zero ^ Zero).evolve(qc).data\n\narray([0.70710678+0.j, 0.70710678+0.j, 0.        +0.j, 0.        +0.j])\n\n\n\nbell_state = (Zero ^ Zero).evolve(qc).evolve(CNOT)\nbell_state.data\n\narray([0.70710678+0.j, 0.        +0.j, 0.        +0.j, 0.70710678+0.j])\n\n\n\narray_to_latex(array=bell_state.data, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & 0 & 0 & \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\nOf course the gate-based nature of IBM devices makes it more natural to directly code our approach as a gate based circuit.\n\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0,1)\n\nqc.draw('mpl')\n\n\n\n\n\n\n\n\nMost likelly moving forward, this pictorical approach will ease the abstraction but is good to know that, the formalism is still there.\n\nprint('Math:', (Zero ^ Zero).evolve(qc).probabilities())\n\nMath: [0.5 0.  0.  0.5]\n\n\nOf course qiskit offers some other nice ways to simulate and visualize the results.\n\nfrom qiskit.quantum_info import Statevector\n\npsi  = Statevector.from_instruction(qc)\n\n\nfrom qiskit.visualization import plot_state_qsphere\n\nplot_state_qsphere(psi)\n\n\n\n\n\n\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(psi)\n\n\n\n\n\n\n\n\nIn order to simulate the actual action of the circuit we will need to add some classical registers and measurement operations.\n\ncircuit = QuantumCircuit(2, 2)\n\ncircuit = circuit.compose(qc)\n\ncircuit.measure([0,1],[0,1])\n\ncircuit.draw('mpl')\n\n\n\n\n\n\n\n\n\nfrom qiskit_aer import AerSimulator\n\n# execute the quantum circuit\nsimulator = AerSimulator()\n\nresult = simulator.run(circuit, shots=1000).result()\ncounts  = result.get_counts(circuit)\nprint(counts)\n\n{'00': 484, '11': 516}\n\n\n\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simulations</span>"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html#exercise",
    "href": "parts/gettingstarted/simulations.html#exercise",
    "title": "1¬† Simulations",
    "section": "1.4 Exercise",
    "text": "1.4 Exercise\nCould we create a state that superposes all potential basis states for a 2-qubit configuration?\n\\[\n|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle\n\\]\n\nqc = QuantumCircuit(2)\n\n# HERE GOES YOUR CIRCUIT\n\n\npsi  = Statevector.from_instruction(qc)\n\nplot_bloch_multivector(psi)\n\n\n\n\n\n\n\n\n\nplot_state_qsphere(psi)\n\n\n\n\n\n\n\n\n\ncircuit = QuantumCircuit(2, 2)\ncircuit = circuit.compose(qc)\ncircuit.measure([0,1],[0,1])\n\n# execute the quantum circuit\nsimulator = AerSimulator()\n\nresult = simulator.run(circuit, shots=1000).result()\ncounts  = result.get_counts(circuit)\n\nplot_histogram(counts)",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simulations</span>"
    ]
  }
]