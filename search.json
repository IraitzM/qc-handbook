[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantum Computing Handbook",
    "section": "",
    "text": "Preface\nYou may wonder, another book about Quantum Computing? Well, by telling it from a different perspective it may help people coming from different fields (meaning, non-physicists) grasp the idea behind quantum computing. This is also a work for myself, as it will definitely help me better understand some of the concepts. Just by explaining things I found it is the best way to challenge ones knowledge about a field you are trying to master.\nAlso, it costs nothing so, no harm done. Code snippets are easier to maintain so hopefully, everything will work with the latest versions. I hope you enjoy reading it as much as I have learned creating it.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Quantum Computing Handbook",
    "section": "About me",
    "text": "About me\nMi name is Iraitz Montalb√°n, Computer Scientist by background, I started in the field of Quantum Computing by chance, while doing an internship in 2010 there were some guys doing something called quantum computing, which was a mathematical framework back then. I kept my interest in the field and ended up doing a masters on Quantum Computing Technologies at UPM and working with some startups in the field.\nFill free to keep in touch.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Well, quantum computing. Really trendy topic. Although it is not the only unconventional computing paradigm out there:\n\nQuantum Computing\nNeuromorphic computing\nAnalog computing\nProbabilistic computing\nThermodynamic computing\nBiological computing\n\nFancy as it might be there are some really cool things we can learn from trying to challenge the status quo. It is not the first paradigm aiming to dethrone classical computing - yes, we will need to do that distinction from now on - but it is certainly the one that has progressed the most. We do have quantum computers, computers the open public can use and that are already fighting in some critical areas making people nervous about it.\nLet‚Äôs see if we can get our heads around what quantum computing is and how to work with it. Let‚Äôs start üéâ",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "parts/gettingstarted/qc-intro.html",
    "href": "parts/gettingstarted/qc-intro.html",
    "title": "Getting started",
    "section": "",
    "text": "What is quantum computing? Well, nothing but a new paradigm to perform computation. It is based on the formalism of quantum physics and even though it might be challenging to grasp at first, just some basic linear algebra might help you understanding the basics. I will try to show it by examples in Python so that it is less challenging and more hands-on.\nClassical computing also embraces physics but at a much higher abstraction level. By being able to manipulate electricity the first devices, analog devices, were able to perform first algorithms. Programming analog devices it is definitely a challenging task, so operation digitization was able to ease that task also making easier for machines to interoperate given that even though different manufacturers where involved, by adopting the same standards in terms of digital operations (time-bounded actions) it made it a lot easier to understand each other.\nBoolean algebra made this possible, providing an universal set of operations to produce the algorithms we do use on a daily basis. Being able to manufacture bits as voltages made possible to build machines capable of following that algebra and abstracting it further to higher level programming languages. The rest is history.\nThe main idea behind quantum computing is that, instead of working at a macroscopic level as we are used to, by using quantum states on some physical mean we could benefit from the effects inherent to quantum physics to perform computation in different ways. By leveraging the those effects some really complex calculations could be performed more efficiently. Don‚Äôt worry, we will be using higher level programming languages as well but we need to understand what is going on under the hood.\nSuperposition, interference and entanglement are the key to most of the speedups claimed in the literature, and we will try to understand how we can work with those in order to produce algorithms for optimization or machine learning tasks.\nHere goes a little roadmap on what has happened in the field in the last two decades:\n\n\n\n\nQC timeline\n\n\n\nThere are plenty of good references on the basic stuff so we will try to link those as well as we cover some specifics around optimization and machine learning more in detail. But let‚Äôs start with the basics: quantum states and qubits.",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "parts/gettingstarted/basics.html",
    "href": "parts/gettingstarted/basics.html",
    "title": "Basics",
    "section": "",
    "text": "Qubits and states\nThe main concept leveraged by quantum computers is the ability to act over quantum states. A quantum state is no other thing than a mathematical description of the probability distribution for the potential outcome after performing a measurement upon a system. It sounds tricky but it is simpler than it sounds, bare with me.\nA quantum computer is a device capable of manipulating quantum states in a specific manner. A quantum state is like a complete description of everything you could possibly know about a tiny physical system, a particle, such as an electron or photon, at any given moment. Think of it this way: imagine you have a coin spinning in the air. While it‚Äôs spinning, you can‚Äôt say it‚Äôs definitively heads or tails - it‚Äôs in a state of being ‚Äúboth‚Äù until it lands. A quantum state is similar, but for particles that are unimaginably small.\nThese states are represented as a normed vector (vector of length 1) as the probability of outcomes should add up to one (meaning, certainty). Let‚Äôs try with the most basic one, a system of a single unit state. The quantum version of a coin looks like:\n\\[\n|\\phi\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\n\\]\nbeing this the minimum representation of a quantum state: a unit norm vector \\(\\in \\mathbb{C}^2\\) whose physical realization is known as the qubit. Qubits do not exists (like bit as a matter of fact), these concepts are pure mathematical constructions that have a specific meaning. In our case, the minimum unit we can manipulate in our quantum computer.\nIt represents the two extremes the system can be at and their probability amplitudes. It means we will observe one or the other if we measure the system and those probabilities must add up to one - \\(|\\alpha|^2+|\\beta|^2 = 1\\) - given that there is certainty that the system exists in one of those options.\nThis state can be decomposed into basic components, the two extreme cases previously mentioned or mathematically speaking, basis states. This is relevant as when it comes to quantum computers, our minimal unit will be expressed on its computational basis: \\[\n|0\\rangle = \\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right]\n\\quad\n|1\\rangle = \\left[\n\\begin{array}{c}\n0 \\\\\n1\n\\end{array}\n\\right]\n\\]\nWe use this simplified Dirac notation just to make it shorter to write, otherwise we will take much of the space writing vectors an matrices. It is funny because those two column vectors will be translated to the already known 0 and 1 bit when we read the state from a classical computer. Classical computers only work with bits so no matter what we do at a quantum level, everything will be then reduced to a set of 0s and 1s. But we will deal with this later when we talk about measurements.\nThus previous state can be described in our qubit unit as:\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right],\n\\]\nmeaning our quantum state‚Äôs potential outcomes are \\(|0\\rangle\\) with probability \\(|\\alpha|^2\\) and \\(|\\beta|^2\\) odds for \\(|1\\rangle\\). How do we know the actual outcome of our state? Well, we need to measure. This is done by projecting our state over one of those basis states, so the complex conjugate of previous vectors is used to know how likely each option is.\n\\[\n\\langle 0 | = \\left[\n\\begin{array}{cc}\n1 & 0\n\\end{array}\n\\right]\n\\quad\n\\langle 1 | = \\left[\n\\begin{array}{cc}\n0 & 1\n\\end{array}\n\\right]\n\\]\nBy projecting our state into this basis vectors we would obtain:\n\\[\n|\\langle 0 |\\psi\\rangle|^2 = \\left|\\left[\n\\begin{array}{cc}\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\\right|^2 = |\\alpha|^2\n\\]\nSo we don‚Äôt actually evaluate the state, but we use a basis vector to see ‚Äúhow close‚Äù our state is to this option that is part of the basis states we are considering.\nAnd here we found one of the first strange things about qubits in comparison to bits. Being 0 and 1 the basic states of a bit, its physical realization can only be in on of those states while qubits can be partially in more than one state creating a superposition of states.",
    "crumbs": [
      "Getting started",
      "Basics"
    ]
  },
  {
    "objectID": "parts/gettingstarted/basics.html#superposition",
    "href": "parts/gettingstarted/basics.html#superposition",
    "title": "Basics",
    "section": "Superposition",
    "text": "Superposition\nThis is one of the trickiest things to get when first approaching quantum computing as it is not so intuitive from our macroscopic perspective. It is also often misunderstood, we will try to make it clear. This is an example of a superposed state\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle.\n\\]\nThe state is a superposed, meaning is a coin spinning in the air and we do not know which state it will reveal when we stop it to look. Our ability to perceive it is limited by the measurement procedure itself, which also alters the condition of the system (stops the coin from spinning), but it is in a set of probabilities during the spinning that is not entirely tied to one specific option (heads or tails).\nWe need to project our quantum state into one of the two potential states we can obtain (\\(|0\\rangle\\) or \\(|1\\rangle\\)). Sadly, when measuring only classical bits can be obtained (0 or 1) into our conventional machines (like the laptop or phone you are using right now), so no probability amplitude, no phase‚Ä¶ quantum information gets lost in the measurement process and we end up with classical (boring) information.\nIn order to fully understand the state while spinning we toss the coin several times and check each time which state we get. With that we plot the outcome of probabilities in a graph. The probability histogram is created after a sequence of quantum state creations and measurements we often call SHOTS. With that we get an idea on how the coin look while spinning.\n\n\n\n\nCoin toss\n\n\n\nFor a series of measurements we have seen \\(|0\\rangle\\) state 50.6% and \\(|1\\rangle\\) state 49.4%. Definitely, looks superposed to me. It is difficult to see from were we stand, but quantum state holds a lot more information than this simple binary choice. In fact, both \\(\\alpha\\) and \\(\\beta\\) are complex numbers, that is why bloch sphere renders a more in detail expression of the state of a qubit. Sadly for us this is something we will never perceive from a real device but it does help while building the formalism or creating algorithms in our heads.\nAll posible states will be part of the surface of that sphere, this is the potential of a single qubit. Not bad.\n\n\n\n\nBloch sphere\n\n\n\nQuantum states can therefore be expressed also as if we consider the polar coordinate:¬°s\n\\[\n|\\phi\\rangle = \\cos (\\theta/2) |0\\rangle + e^{i\\phi} \\sin (\\theta/2)|1\\rangle\n\\]\nwhich represent the sphere coordinates on the surface of the bloch sphere. It is more evident in this case that rendering simple bits will actually remove most of the information (like phase) contained in the states when operating with them in the quantum regime.",
    "crumbs": [
      "Getting started",
      "Basics"
    ]
  },
  {
    "objectID": "parts/gettingstarted/basics.html#measurement",
    "href": "parts/gettingstarted/basics.html#measurement",
    "title": "Basics",
    "section": "Measurement",
    "text": "Measurement\nMeasuring quantum states is a necessary condition to extract information out of it, but by doing so we affect the system due to the collapse of the wave function. I know, too technical.\nOk, so when we observe a quantum state we can only see one of the potential outcomes, the one we observe actualy. And this affects the system, meaning when we look at it it collapses to the state we have observed and no longer exsits as a probability ditribution but as a certainty.\nThe action we use to observe the quantum state is by means of Observables (self-adjoint operators). These are used to project the measurement of a given quantum state to one of its eigenvalues. Using the closeness between quantum state and eigenvectors of the observable we can measure what is the overlap between those. The eigenvectors of the observable form an orthonormal basis for the Hilbert space, therefore each measure corresponds to a mapping to the eigenvectors comprising the basis. I know, this is a little bit too technical but just think about the observable as a pair of tinted glasses, if glasses have a green-ish color, everything will look some sort of green: dark green for black or light green for white. It is kind of like that. Kind of.\nWe will see that a common observable used is the Pauli \\(\\sigma_z\\) matrix\n\\[\n\\sigma_z = \\left[\n\\begin{array}{cc}\n1 & 0 \\\\\n0 & -1\n\\end{array}\n\\right]\n\\]\nWe can decompose it on its eigenvectors and eigenvalues so that\n\\[\n\\sigma_z|0\\rangle = 1|0\\rangle \\rightarrow \\sigma_z|1\\rangle = -1|1\\rangle.\n\\]\nTherefore, any potential measurement will be mapped to one of those two eigenvectors and its eigenvalue used as the outcome of the measurement. The basis set shown above is often known as the computational basis and it will become relevant when we move to actual implementations.\nFrom our previous state \\(|\\phi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle\\) and perform a measurement over the computational basis (\\(|0\\rangle,|1\\rangle\\)) where evidently the outcome would be \\(|0\\rangle\\) with \\(|\\alpha|^2\\) probability or \\(|1\\rangle\\) with \\(|\\beta|^2\\) probability. But more importantly, a single measurement, no matter how complex, entangled or superposed our state might be, will only be able to recover classical bits mapping two previously seen states (\\(|0\\rangle \\rightarrow 0\\) and \\(|1\\rangle \\rightarrow 1\\)).\nWhat happens after measurement is performed? Well, that is the trickiest part as the process of measuring obliges to our quantum state to position itself and make a choice. This means our quantum state after measurement will no longer be in a superposition state and will be the outcome of the previous measurement \\(|0\\rangle\\) for the remaining time period.\nIn order to fully grasp the statistics of the state we should find way to reproduce the state and perform enough measurements, so we can characterize its actual condition as much as we can out of the measurement statistics it presents. Measuring in the basis \\(\\{|0\\rangle, |1\\rangle\\}\\) (also called computational basis) may not be enough to capture the actual state. Therefore, a basis change is needed, but we will see that quantum devices only offer computational basis as the measuring basis. That means in certain cases we will need to rotate our qubits so that the basis change is artificially done.\nIf we would like to measure in the \\(\\{|+\\rangle, |-\\rangle\\}\\) basis then a rotation of \\(-\\pi / 2\\) in the Y axis will be needed. \\(\\{|i\\rangle, |-i\\rangle\\}\\) basis will require then a rotation over X axis of \\(\\pi / 2\\). That way we get to shift the reference point and measure according to our target axis.\nNext thing is to operate on those things, let‚Äôs see how gates differ from our knowledge from classical computing.",
    "crumbs": [
      "Getting started",
      "Basics"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html",
    "href": "parts/gettingstarted/gates.html",
    "title": "Quantum gates",
    "section": "",
    "text": "The Hall of Gates\nNow that we know how our states might look like\n\\[\n|\\phi\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\n\\]\nwould be relevant to understand how we can operate on them. Quantum computers, like classical computers, use logical gates to do their work. In this case, gates are operations that take our initial state and convert it into a different quantum state. Classical regime is poor in this sense as allowed changes are only between 0 and 1, but quantum states and qubits allow for much more information to be represented. That makes quantum logical gates also more complex and rich.\n\\[\nU|\\psi\\rangle \\rightarrow |\\phi\\rangle\n\\]\nBut in this case, these gates are specific to the quantum regime. We will find some similarities like in the case of the not gate and some particular cases like the Hadamard gate.\nA quantum gate is a frame to describe the quantum process taking a quantum state at time \\(t\\) to the one at \\(t+1\\). For a closed quantum system the operator that describes the evolution of the system can be described with \\(e^{-i\\int H dt/\\hbar}\\), which is a unitary operator based on the Hamiltonian that describes the dynamics of the system. What is a Hamiltonian you ask? Well, this video may be of interest then:\nJust take into account that, if we ignore the global phase of the quantum state, we can suppose all the quantum gates to be special unitary operations, i.e., the determinant of them is 1. This is so that the obtained state falls into the surface of the bloch sphere (otherwise we enter a much more complex territory).\nAs in classical computing, some key gates need to be known. The \\(NAND\\) being an universal boolean logic gate as it can create all the other options required to render boolean logic, we should introduce some of the core gates when talking about quantum computing and the universality of those gates.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#the-hall-of-gates",
    "href": "parts/gettingstarted/gates.html#the-hall-of-gates",
    "title": "Quantum gates",
    "section": "",
    "text": "NOT-gate (X)\nThe not gate (\\(X\\) as the operator gate and \\(\\sigma_x\\) if expressed as a Pauli matrix) is one of the most basic concepts in computing. A classical operation that takes the bit in a position (0 or 1) to its opposite. But, quantum not extends that basic concept to the complexity of the quantum regime. The operator can be represented by a matrix like the following one:\n\\[\nX = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\n\\]\nThen, the operation \\(X|0\\rangle = |1\\rangle\\) can be validated by the simple multiplication of the matrix of the gate by the quantum state:\n\\[\nX|0\\rangle = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n0 \\\\\n1\n\\end{array}\n\\right] = |1\\rangle\n\\]\nBut if we perform this very simple example with the generic case for \\(|\\psi\\rangle\\)\n\\[\nX|\\psi\\rangle = X(\\alpha|0\\rangle + \\beta |1\\rangle) = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n\\beta \\\\\n\\alpha\n\\end{array}\n\\right] = \\beta|0\\rangle + \\alpha |1\\rangle = |\\phi\\rangle\n\\]\nwe have basically created a new state where its outcome probabilities have been shifted. Therefore, the \\(X\\) operation can be used to shift the state ratter than perform a mere coin flipping. This gets more interesting looking at some specific gates like the Hadamard gate.\n\n\nHadamard (H)\nIts matrix representation is\n\\[\nH = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\n\\]\nAnd its effect‚Ä¶\n\\[\nH|0\\rangle = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{c}\n1 \\\\\n1\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle = |+\\rangle\n\\]\nbasically it allows as to switch the axis of the bloch sphere and work on the superposition of the states on the \\(Z\\) axis.\n\n\n\n\nBloch sphere",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#rotating-quantum-states",
    "href": "parts/gettingstarted/gates.html#rotating-quantum-states",
    "title": "Quantum gates",
    "section": "Rotating quantum states",
    "text": "Rotating quantum states\nIn essence, we will see that many gates what they offer us is simply rotations over the three main axes of the bloch sphere:\n\\[\nR_x(\\theta) = \\left(\n    \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -i\\sin(\\frac{\\theta}{2}) \\\\\n        -i\\sin(\\frac{\\theta}{2}) & \\cos(\\frac{\\theta}{2})\n    \\end{array}\n    \\right)\n\\]\n\\[\nR_y(\\theta) = \\left(\n    \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -\\sin(\\frac{\\theta}{2}) \\\\\n        \\sin(\\frac{\\theta}{2}) & \\cos(\\frac{\\theta}{2})\n    \\end{array}\n    \\right)\n\\]\n\\[\nR_z(\\theta) = \\left(\n    \\begin{array}{cc}\n        e^{-i\\frac{\\theta}{2}} & 0 \\\\\n        0 & e^{i\\frac{\\theta}{2}}\n    \\end{array}\n    \\right)\n\\]\nmaking the general case \\(R_M(\\theta) = \\exp^{(‚àíi\\theta M/2)}\\) where \\(M \\in \\{X,Y,Z\\};\\) being those three the Pauli gates the Pauli matrices \\(\\sigma_x, \\sigma_y \\text{ and } \\sigma_z\\). Actually the literature will quote a more generic case which will be given by the following gate operator\n\\[\nU(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc}\n        \\cos(\\frac{\\theta}{2}) & -e^{i\\lambda}\\sin(\\frac{\\theta}{2})\\\\\n        e^{i\\phi}\\sin(\\frac{\\theta}{2}) & e^{i(\\phi+\\lambda)}\\cos(\\frac{\\theta}{2})\n    \\end{array} \\right)\n\\]\nwhich maps to previous gates following the relationship \\(U(\\theta,0,0) = R_y(\\theta)\\), \\(U(0,0,\\lambda) = R_z(\\lambda)\\) and \\(U(\\theta,-\\frac{\\pi}{2},\\frac{\\pi}{2}) = R_x(\\theta)\\)",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#native-gates",
    "href": "parts/gettingstarted/gates.html#native-gates",
    "title": "Quantum gates",
    "section": "Native gates",
    "text": "Native gates\nQuantum Computing is a mathematical framework that allows for all kind of gates to be designed but in many cases depending on the manufacturer of the device the set of gates we can use may differ. We will need to find the combination of gates that will produce our desired action by using the gates each device is equipped with. Also called native gates.\nThe native gate set is the gate set, one and two-qubit gates, that should be used to translate any theoretical operator or action from the mathematical framework to be physical action that can be performed, decomposing the original action into different operations or better expressed, transpiling the circuit.\n\n\n\n\n\n\nYou won‚Äôt believe this but‚Ä¶\n\n\n\n\n\nActually, two of the most basic gates, the Hadamard and CNOT gate, do not exist. We always need to find translations for those fundamental operations when dealing with hardware.\n\n\n\nOur circuit:\n\n\n\n\nSome circuit\n\n\n\n\\(H\\) represents the Hadamard gate and the other two blue ones, the Control-NOT gate as the basis for generating entangled states.\nNo device can implement natively at least to the best of our knowledge. Therefore, in order to apply that gate own needs to apply native gates that produce the same action or unitary matrix.\nWhat can run on IBM devices if we convert it to\n\n\n\n\nTranspiled circuit\n\n\n\nWe will see this in more detail later when we review hardware providers and their actual implementation.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#control-not-cnot",
    "href": "parts/gettingstarted/gates.html#control-not-cnot",
    "title": "Quantum gates",
    "section": "Control-NOT (CNOT)",
    "text": "Control-NOT (CNOT)\nOne interesting gate to be implemented in this regime is the control not or CNOT gate. This acts on the target qubit only if the first qubit is at \\(|1\\rangle\\) state. It does not require any classical measurement or observation, meaning the control qubit still holds its quantumness after gate operation. This is critical to the good functioning of the system otherwise any classical action would affect the quantum state making it purely classical.\n\\[\nCNOT|00\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n1 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n1 \\\\\n0 \\\\\n0 \\\\\n0\n\\end{array}\n\\right] = |00\\rangle\n\\]\n\\[\nCNOT|10\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n0 \\\\\n0 \\\\\n1 \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n0 \\\\\n0 \\\\\n0 \\\\\n1\n\\end{array}\n\\right] = |11\\rangle\n\\]\nBut what does there happen when it gets applied to a superposed state.\n\\[\nCNOT|+0\\rangle = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\frac{1}{\\sqrt{2}} \\\\\n0 \\\\\n\\frac{1}{\\sqrt{2}} \\\\\n0\n\\end{array}\n\\right] = \\left[\n\\begin{array}{c}\n\\frac{1}{\\sqrt{2}} \\\\\n0 \\\\\n0 \\\\\n\\frac{1}{\\sqrt{2}}\n\\end{array}\n\\right] = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\n\\]\nQuite interesting. Have you tried decomposing this state into the tensor product of the quantum state of the two qubits?\nIt is fine, because it is not possible. This is what it is called an entangled state. One particular benefit of this states is that by measuring only one of those qubits we know the value of the second one without any need for measurement. We cannot act on one party without affecting the whole system, but we also know the condition of the other party by observing just one. This is what Einstein called spooky actions at a distance and are critical to the scalability of the quantum algorithms.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/gates.html#entanglement",
    "href": "parts/gettingstarted/gates.html#entanglement",
    "title": "Quantum gates",
    "section": "Entanglement",
    "text": "Entanglement\nEntangled states are critical for some of the quantum algorithms allowing us to outperform (theoretically at least) classical computing. The most basic (and probably best known) entangled states are the Bell states or EPR pairs.\n\\[\n|\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\quad |\\Phi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle - |11\\rangle)\n\\]\n\\[\n|\\Psi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle + |10\\rangle) \\quad |\\Psi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|10\\rangle - |10\\rangle)\n\\]\nEntangled states are behind some of the key algorithms in communication protocols such as Quantum Teleportation or Superdense coding or behind the post-quantum cryptography proposals, like the Quantum Key Distribution. But they are also relevant for computations as we will see in the following sections.\nI know, too much theory. Let‚Äôs try to execute some examples to make it more clear.",
    "crumbs": [
      "Getting started",
      "Quantum gates"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html",
    "href": "parts/gettingstarted/simulations.html",
    "title": "Simulations",
    "section": "",
    "text": "From scratch\nNow, do we have to create our own set of gates and operations? Well, it might be a good practice as the formalism can be easily reproduced by setting the basic needs:\nWe can then create our own set of functions and objects to simulate those computations:\nWe would easily create basic vector structures for our quantum framework. The minimum unit is the qubit and in order to frame the potential quantum states it may hold we would need to create the computational basis set \\(\\{|0\\rangle, |1\\rangle \\}\\).\nimport numpy as np\nfrom qiskit.visualization import array_to_latex\n\nzero = [[1], [0]]\n\narray_to_latex(array=zero, prefix='|0\\\\rangle = ', max_size=(10,10))\n\n\\[\n|0\\rangle =\n\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\n\\]\none = [[0], [1]]\n\narray_to_latex(array=one, prefix='|1\\\\rangle = ', max_size=(10,10))\n\n\\[\n|1\\rangle =\n\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\n\\]\nNow lets try with some gates.\n\\[\nX = \\left[\n\\begin{array}{cc}\n0 & 1 \\\\\n1 & 0\n\\end{array}\n\\right] \\quad\nH = \\frac{1}{\\sqrt{2}}\\left[\n\\begin{array}{cc}\n1 & 1 \\\\\n1 & -1\n\\end{array}\n\\right]\n\\]\nX = [[0,1],[1,0]]\n\narray_to_latex(array=X, prefix='X = ', max_size=(10,10))\n\n\\[\nX =\n\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\n\\]\nhadamard = np.dot((1/(np.sqrt(2))), [[1, 1], [1, -1]])\n\narray_to_latex(array=hadamard, prefix='H = ', max_size=(10,10))\n\n\\[\nH =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\nWell, it is already taking shape. We can test if the outcome matches our expectations.\nsuperposition = np.dot(hadamard, zero)\n\narray_to_latex(array=superposition, prefix='H|0\\\\rangle = |+\\\\rangle = ', max_size=(10,10))\n\n\\[\nH|0\\rangle = |+\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\none = np.dot(X, zero)\n\narray_to_latex(array=one, prefix='X|0\\\\rangle = |1\\\\rangle = ', max_size=(10,10))\n\n\\[\nX|0\\rangle = |1\\rangle =\n\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\n\\]\nWe can scale it to a couple of qubits to see what we get. Let‚Äôs try to create on of the bell states we saw during class.\n\\[\n|\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\quad |\\Phi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle - |11\\rangle)\n\\] \\[\n|\\Psi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle + |10\\rangle) \\quad |\\Psi^{-}\\rangle = \\frac{1}{\\sqrt{2}}(|10\\rangle - |10\\rangle)\n\\]\nWe will need the CNOT gate for this.\nCNOT = [[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]\n\narray_to_latex(array=CNOT, prefix='CNOT = ', max_size=(10,10))\n\n\\[\nCNOT =\n\\begin{bmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 1 & 0 & 0  \\\\\n0 & 0 & 0 & 1  \\\\\n0 & 0 & 1 & 0  \\\\\n\\end{bmatrix}\n\\]\nWith this we will create a two qubit system, apply the Hadamard gate to the first one and the CNOT gate with the conrol over the first qubit as well.\n# Initial state\ninit_state = np.kron(zero, zero)\n\n# (I tensor Hadamard)\nHI = np.kron(hadamard, np.eye(2))\nWith that we can perform the full operation\n\\[\nCNOT (I\\otimes H)|00\\rangle = |\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle\n\\]\npsi_1 = np.dot(HI, init_state)\npsi = np.dot(CNOT, psi_1)\n\narray_to_latex(array=psi, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2}  \\\\\n0  \\\\\n0  \\\\\n\\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\nThere you go. This is our entangled 2-qubit state. Building the whole formalism from scratch might be tedious, but it helps us understand every detail of it.\nOf course, in order to continue forward, we will take advantage of the collective effort and use some existing tools to ease our way into quantum computing.",
    "crumbs": [
      "Getting started",
      "Simulations"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html#qutip",
    "href": "parts/gettingstarted/simulations.html#qutip",
    "title": "Simulations",
    "section": "QuTip",
    "text": "QuTip\nOf course, we are not the first ones with this need, so there do exist some quite useful libraries in this domain. QuTiP might be one of the most used ones (at least for us, Python enthusiasts).\n\nimport scipy\nimport numpy as np\nfrom qutip import Qobj, mesolve\nfrom qutip import basis, tensor\nfrom qutip.qip.operations import cnot\n\n# Basis states\nzero = basis(2,0)\none = basis(2,1)\n\n# |10&gt;\none_zero = tensor(one, zero)\n\n# CNOT\nhamiltonian = cnot().full()\n\n# e^itH\nu_generator = Qobj(1j * scipy.linalg.logm(hamiltonian), dims=[[2] * 2] * 2)\n\n# Time range 0.0 -&gt; 1.0\ntimes = np.arange(0, 1.1, 0.1)\n\n# \\psi = H\\psi_0\nevolution = mesolve(u_generator, one_zero, times)\n\n\nevolution.states[0]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [0.]\n [1.]\n [0.]]\n\n\n\nevolution.states[1]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.        +0.j        ]\n [0.        +0.j        ]\n [0.97552824+0.15450855j]\n [0.02447175-0.15450855j]]\n\n\n\nevolution.states[-1]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.00000000e+00+0.00000000e+00j]\n [0.00000000e+00+0.00000000e+00j]\n [1.07316277e-06+9.88099162e-07j]\n [1.00000000e+00-9.88099162e-07j]]\n\n\nLet‚Äôs go by steps.\n\nfrom qutip import basis, tensor\n\none = basis(2,1)\nzero = basis(2,0)\n\none_zero = tensor(one, zero) # |10&gt;\none_zero\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [0.]\n [1.]\n [0.]]\n\n\n\nfrom qutip.qip.operations import cnot\n\ncnot_matrix = cnot().full()\ncnot_matrix\n\narray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n\n\nIn fact, it allows us to do more than just the simple operations we envisioned. For example, we could generate the whole evolution over a period of time of the \\(U\\) unitary generated for our Hamiltonian.\n\nfrom qutip import identity\nfrom qutip.qip.operations import hadamard_transform\n\n# hamiltonian\nhamiltonian =  cnot() * tensor(hadamard_transform(1), identity(2))\nhamiltonian\n\nQuantum object: dims=[[2, 2], [2, 2]], shape=(4, 4), type='oper', dtype=Dense, isherm=False\nQobj data =\n[[ 0.70710678  0.          0.70710678  0.        ]\n [ 0.          0.70710678  0.          0.70710678]\n [ 0.          0.70710678  0.         -0.70710678]\n [ 0.70710678  0.         -0.70710678  0.        ]]\n\n\n\nimport numpy as np\nimport scipy\nfrom qutip import Qobj, mesolve\n\n# Initial state\ninit_state = tensor(zero, zero) # |00&gt;\n\n# e^itH\nu_generator = Qobj(1j * scipy.linalg.logm(hamiltonian.full()), dims=[[2] * 2] * 2)\n\n# Time range\ntimes = np.arange(0, 1.1, 0.1)\nevolution = mesolve(u_generator, init_state, times)\n\n\nevolution.states[0]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[1.]\n [0.]\n [0.]\n [0.]]\n\n\n\nevolution.states[1]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[ 0.99487486+0.02262725j]\n [-0.00204247+0.02262725j]\n [-0.03057749-0.05462701j]\n [ 0.04788161-0.05462701j]]\n\n\n\nevolution.states[-1]\n\nQuantum object: dims=[[2, 2], [1]], shape=(4, 1), type='ket', dtype=Dense\nQobj data =\n[[ 7.07106734e-01-2.77290950e-08j]\n [-2.74299654e-08-2.77290950e-08j]\n [ 6.61796919e-08+6.69439574e-08j]\n [ 7.07106828e-01+6.69439574e-08j]]\n\n\n\npsi = np.round(evolution.states[-1].full(), decimals = 5)\n\narray_to_latex(array=psi, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n0.70711  \\\\\n0  \\\\\n0  \\\\\n0.70711  \\\\\n\\end{bmatrix}\n\\]\n\n\nLooks like \\(\\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\\) but due to numerical imprecisions we wil get this type of ugly structures in between. We will need to familiarize with those artifacts as noise when using hardware will produce similar numerical artifacts.\nWell, having a theoretical framework may be a good option for simulating and doing some local experimentation but that will reach soon limitations when trying to scale it up. Our classical device won‚Äôt be able to perform the whole system calculations and we might need to switch to actual quantum computers doing those. Therefore, we need to find a way to o so.\nThis is why some manufacturers have invested time and effort on creating open-source frameworks to be adopted by the community (and position themselves). Companies such as IBM or AWS have leveraged their own version that also allows for these programs to be sent to an end device that will perform the set of operations.\n\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2, 2)\nqc.x(0)\nqc.cx(0, 1)\nqc.measure([0,1], [0,1])\n\nqc.draw('mpl')",
    "crumbs": [
      "Getting started",
      "Simulations"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html#qiskit",
    "href": "parts/gettingstarted/simulations.html#qiskit",
    "title": "Simulations",
    "section": "Qiskit",
    "text": "Qiskit\nQiskit is IBM‚Äôs quantum computing toolkit the enables interaction with their devices. Let‚Äôs first start replicating the theoretical basis and then move forward up to device simulation.\nOpflow is the framework section dedicated to provide the pieces to perform previous computations.\n\nfrom qiskit.quantum_info import Statevector\n\nZero = Statevector.from_label('0')\nOne = Statevector.from_label('1')\n\n\nprobs = Zero.probabilities()\nprint('Probability of measuring 0: {}'.format(probs[0]))\n\nProbability of measuring 0: 1.0\n\n\n\nprint('Probability of measuring 1: {}'.format(probs[1]))\n\nProbability of measuring 1: 0.0\n\n\n\nPlus = Statevector.from_label('+')\n\nprint(Plus)\n\nStatevector([0.70710678+0.j, 0.70710678+0.j],\n            dims=(2,))\n\n\n\nPlus.probabilities()\n\narray([0.5, 0.5])\n\n\nQiskit tends to understand everything in terms of circuits. But in essence we can request the actual operation being performed there and check that the Hadamard action over a \\(|0\\rangle\\) state (the initial state) provides the \\(|+\\rangle\\) state as expected.\n\narray_to_latex(array=Plus.data, prefix='|+\\\\rangle = ', max_size=(10,10))\n\n\\[\n|+\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\nWhat would be the outcome of it?\n\nprobs = Plus.probabilities()\nprint('Probability of measuring 0: {}'.format(probs[0]))\n\nProbability of measuring 0: 0.4999999999999999\n\n\nThis is the expected outcome for the \\(\\langle 0 | \\psi \\rangle\\) operation. But we can mimic it as well.\n\nprint(abs(np.dot(Zero.data, Plus.data.T)**2))\n\n0.4999999999999999\n\n\nSimilarly gate operations can be used.\n\nfrom qiskit.quantum_info import Pauli\n\nX = Pauli('X')\n\nAnd what is the amplitude of \\(|1\\rangle\\) after the \\(X|0\\rangle\\) operation?\n\nZero.evolve(X) == One\n\nTrue\n\n\nQiskit orders bits in a specific manner so some gates may look different but is just a matter of ordering when applying the operations.\n\nfrom qiskit.circuit.library import UnitaryGate\n\nmatrix = [[1., 0., 0., 0.],\n          [0., 0., 0., 1.],\n          [0., 0., 1., 0.],\n          [0., 1., 0., 0.]]\nCNOT = UnitaryGate(matrix)\n\nLet play around with the Bell state we produced before\n\\[\nCNOT (I\\otimes H)|00\\rangle = |\\Phi^{+}\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle\n\\]\n\nprint(Zero ^ Zero)\n\nStatevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n            dims=(2, 2))\n\n\n\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2)\nqc.h(0)\n\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê\nq_0: ‚î§ H ‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò\nq_1: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n          \n\n\n\nfrom qiskit.quantum_info import Operator\n\nprint(Operator(qc).data)\n\n[[ 0.70710678+0.j  0.70710678+0.j  0.        +0.j  0.        +0.j]\n [ 0.70710678+0.j -0.70710678+0.j  0.        +0.j  0.        +0.j]\n [ 0.        +0.j  0.        +0.j  0.70710678+0.j  0.70710678+0.j]\n [ 0.        +0.j  0.        +0.j  0.70710678+0.j -0.70710678+0.j]]\n\n\n\n(Zero ^ Zero).evolve(qc).data\n\narray([0.70710678+0.j, 0.70710678+0.j, 0.        +0.j, 0.        +0.j])\n\n\n\nbell_state = (Zero ^ Zero).evolve(qc).evolve(CNOT)\nbell_state.data\n\narray([0.70710678+0.j, 0.        +0.j, 0.        +0.j, 0.70710678+0.j])\n\n\n\narray_to_latex(array=bell_state.data, prefix='|\\\\psi\\\\rangle = ', max_size=(10,10))\n\n\\[\n|\\psi\\rangle =\n\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & 0 & 0 & \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\n\\]\n\n\nOf course the gate-based nature of IBM devices makes it more natural to directly code our approach as a gate based circuit.\n\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0,1)\n\nqc.draw('mpl')\n\n\n\n\n\n\n\n\nMost likelly moving forward, this pictorical approach will ease the abstraction but is good to know that, the formalism is still there.\n\nprint('Math:', (Zero ^ Zero).evolve(qc).probabilities())\n\nMath: [0.5 0.  0.  0.5]\n\n\nOf course qiskit offers some other nice ways to simulate and visualize the results.\n\nfrom qiskit.quantum_info import Statevector\n\npsi  = Statevector.from_instruction(qc)\n\n\nfrom qiskit.visualization import plot_state_qsphere\n\nplot_state_qsphere(psi)\n\n\n\n\n\n\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(psi)\n\n\n\n\n\n\n\n\nIn order to simulate the actual action of the circuit we will need to add some classical registers and measurement operations.\n\ncircuit = QuantumCircuit(2, 2)\n\ncircuit = circuit.compose(qc)\n\ncircuit.measure([0,1],[0,1])\n\ncircuit.draw('mpl')\n\n\n\n\n\n\n\n\n\nfrom qiskit_aer import AerSimulator\n\n# execute the quantum circuit\nsimulator = AerSimulator()\n\nresult = simulator.run(circuit, shots=1000).result()\ncounts  = result.get_counts(circuit)\nprint(counts)\n\n{'11': 493, '00': 507}\n\n\n\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)",
    "crumbs": [
      "Getting started",
      "Simulations"
    ]
  },
  {
    "objectID": "parts/gettingstarted/simulations.html#exercise",
    "href": "parts/gettingstarted/simulations.html#exercise",
    "title": "Simulations",
    "section": "Exercise",
    "text": "Exercise\nCould we create a state that superposes all potential basis states for a 2-qubit configuration?\n\\[\n\\frac{1}{2}|00\\rangle + \\frac{1}{2}|01\\rangle + \\frac{1}{2}|10\\rangle + \\frac{1}{2}|11\\rangle\n\\]\n\nqc = QuantumCircuit(2)\n\n# HERE GOES YOUR CIRCUIT\n\n\npsi  = Statevector.from_instruction(qc)\n\nplot_bloch_multivector(psi)\n\n\n\n\n\n\n\n\n\nplot_state_qsphere(psi)\n\n\n\n\n\n\n\n\n\ncircuit = QuantumCircuit(2, 2)\ncircuit = circuit.compose(qc)\ncircuit.measure([0,1],[0,1])\n\n# execute the quantum circuit\nsimulator = AerSimulator()\n\nresult = simulator.run(circuit, shots=1000).result()\ncounts  = result.get_counts(circuit)\n\nplot_histogram(counts)",
    "crumbs": [
      "Getting started",
      "Simulations"
    ]
  },
  {
    "objectID": "parts/computers/firstrealizations.html",
    "href": "parts/computers/firstrealizations.html",
    "title": "First realizations",
    "section": "",
    "text": "Building the thing\nMotivated by Shor‚Äôs algorithm (Shor 1994), during late 90s there was quite some motivation to provide a physical realization of what up to that moment was mostly theoretical work.\nAny two-level physical system could be a good candidate for a qubit but we need to a find a physical realization that allows for operation and performing the set of tasks we could consider an algorithm.\nIn 1998, using nuclear magnetic resonance (NMR) both Oxford University and Stanford achieved the first implementations of two qubit algorithms (Chuang, Gershenfeld, and Kubinec 1998). More or less in the same period, Yasunobu Nakamura and Jaw-Shen Tsai demonstrated how a superconducting chip can be used as a qubit by controlling the current through it (Nakamura, Pashkin, and Tsai 2001).\n2007 is known to be a key date as the first transmon was born. It is the equivalent of the transistor in the quantum regime (Koch et al. 2007). So first qubits exist since early 2000 which is not much but from manufacturing a qubit to building a whole computer‚Ä¶ that is a long road.\nMany metrics will be used to compare different devices and realizations in following sections so better get them clear now.\nT1 time\nAlso known as the relaxation time, identifies how much time it would take a qubit to transition from an excited state (\\(|1\\rangle\\)) to its ground state (\\(|0\\rangle\\)). T1 time is not an actual time from state to state but rather identifies the time in which a state might transition and flips states once exited (\\(P(|1\\rangle) = e^{-\\frac{t}{T1}}\\)).\nT2 time\nKnown as the phase coherence time. Basically quantifies the time in which the phase associated to a state is stable.\n\\[\n|+\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} \\quad \\xrightarrow[T2]{} \\quad |-\\rangle = \\frac{|0\\rangle -|1\\rangle}{\\sqrt{2}}\n\\]\nThese two time-metrics characterize our qubits coherence time, the time in which our qubits are actually qubits and not classical bits playing tricks on us.\nAnother measure we will often refer to is the fidelity. Basically it measures the gap between theoretical state and physical outcome as a qubit quality metric. Fidelity attends to the more general state of closeness between two quantum states but in this following sections it will provide a measure to understand how well each operation renders the expected result.\n\\[\nF(\\rho, \\sigma) = |\\langle \\psi | \\phi \\rangle | ^2\n\\]\nThere is more than one type of quantum computer. Actually we yet don‚Äôt know the one that will win the podium, but the race is interesting at this point. The physical realization conditions many aspects of the whole machine so it is relevant to understand a bit of their inner workings so that we can select the most appropriate option.\nThere is one general definition of how a quantum computer may look like and it is given by the DiVincenzo criteria (DiVincenzo 1997).\nWith this recipe many platforms have been proposed using different physical realizations for the technology.",
    "crumbs": [
      "Building a quantum computer",
      "First realizations"
    ]
  },
  {
    "objectID": "parts/computers/firstrealizations.html#building-the-thing",
    "href": "parts/computers/firstrealizations.html#building-the-thing",
    "title": "First realizations",
    "section": "",
    "text": "Must be scalable and well characterized qubits.\nSystem may be able to be initialized (\\(|00...\\rangle\\) state is the common choice)\nQubit coherence time must be much larger than the actuation time\nEnable a universal set of gates/operations\nCapable of measuring from specific qubits\n\n\n\n\n\n\nChuang, Isaac L, Neil Gershenfeld, and Mark Kubinec. 1998. ‚ÄúExperimental Implementation of Fast Quantum Searching.‚Äù Physical Review Letters 80 (15): 3408.\n\n\nDiVincenzo, David P. 1997. ‚ÄúTopics in Quantum Computers.‚Äù In Mesoscopic Electron Transport, 657‚Äì77. Springer.\n\n\nKoch, Jens, Terri M Yu, Jay Gambetta, Andrew A Houck, David I Schuster, Johannes Majer, Alexandre Blais, Michel H Devoret, Steven M Girvin, and Robert J Schoelkopf. 2007. ‚ÄúCharge-Insensitive Qubit Design Derived from the Cooper Pair Box.‚Äù Physical Review A‚ÄîAtomic, Molecular, and Optical Physics 76 (4): 042319.\n\n\nNakamura, Y, Yu A Pashkin, and Jaw Shen Tsai. 2001. ‚ÄúRabi Oscillations in a Josephson-Junction Charge Two-Level System.‚Äù Physical Review Letters 87 (24): 246601.\n\n\nShor, Peter W. 1994. ‚ÄúAlgorithms for Quantum Computation: Discrete Logarithms and Factoring.‚Äù In Proceedings 35th Annual Symposium on Foundations of Computer Science, 124‚Äì34. Ieee.",
    "crumbs": [
      "Building a quantum computer",
      "First realizations"
    ]
  },
  {
    "objectID": "parts/computers/technology.html",
    "href": "parts/computers/technology.html",
    "title": "Technology",
    "section": "",
    "text": "Superconducting chips\nIn order to create a machine that is able to execute the mathematical framework described by quantum computation, different technologies can be used.\nSuperconducting qubits are implemented using macroscopic elements build using a LC electrical circuit. The effect of an electrical resonator is observed at specific work temperatures below 15mK which requires building quite large dilution refrigerators. One of the main disadvantages of this technology is their susceptibility to environment noise (sources being dielectric of surrounding metal or surrounding energy radiations) that cause short coherence times.\nProbably one of the most mature implementations when it comes to qubit realization. Companies like IBM, Intel, Google or D-Wave base their devices in this technology. The most popular qubit, the transmon, offers coherence times between 50 and 100 \\(\\mu\\)s with operation times in the order of nanoseconds (fastest: 18 ns demonstration in 2019). This leaves an operation ratio of \\(10^{4}\\) satisfying 3rd DiVincenzo criteria. Qubit fidelity reach the 99.95% with experiments reporting 99.66% for two qubit gate in 2016.\nWorks by controlling the current flow through the superconducting circuit and those current flows can be operated using microwave pulses. Different pulse configurations (length, amplitude or phase) represent the potential digitized gates one could find.\nCircuit topology is often limited to nearest-neighbor couplings, which limits the implementation of densely connected algorithms.\nThese devices can handle up to 433 qubits (IBM‚Äôs Osprey architecture) on their digital version but D-Wave‚Äôs annealing machine counts with up to 8000 qubits to be used.\nTo know a bit more about the inner workings, go to Xanadu‚Äôs thorough explanation.",
    "crumbs": [
      "Building a quantum computer",
      "Technology"
    ]
  },
  {
    "objectID": "parts/computers/technology.html#superconducting-chips",
    "href": "parts/computers/technology.html#superconducting-chips",
    "title": "Technology",
    "section": "",
    "text": "Superconducting\n\n\n\n\n\n\n\n\n\n\n\nProvider\nMax. Qubits\n\n\n\n\nD-Wave\n8000\n\n\nIBM\n433\n\n\nRigetti\n80\n\n\nOQC\n32",
    "crumbs": [
      "Building a quantum computer",
      "Technology"
    ]
  },
  {
    "objectID": "parts/computers/technology.html#trapped-ions",
    "href": "parts/computers/technology.html#trapped-ions",
    "title": "Technology",
    "section": "Trapped ions",
    "text": "Trapped ions\nInitially proposed by Cirac and Zoller (Cirac and Zoller 1995), ions are confined into traps making up the quantum computer composed of those.\n\n\n\n\nIon trap\n\n\n\nPairs of internal electronic states of ions are implemented as the base qubit states \\(|0\\rangle\\) and \\(|1\\rangle\\). They can be any combination of long-lived levels, differentiated by the separation of their energy levels. The 2 most predominant ones are hyperfine levels, separated by gigahertz frequencies; and optical levels, separated by frequencies of hundreds of terahertz.\nAfter the ions are loaded into their traps, the qubits are optically pumped into the fiducial state of \\(|1\\rangle\\). The methodology of gate operation via state transition is dependent on the type of trapped-ion qubit. For optical qubits, a laser with a resonant frequency equal to the state transition is used whereas gate operations on hyperfine qubits can be performed either with lasers using stimulated Raman Coupling or with microwaves directly addressing the giga-hertz energy level splitting.\nThe state-dependent readout is carried out by lasers as well. Using contemporary methods, readout fidelities of over 99.9% have been achieved within microseconds (Myerson et al. 2008; Crain et al. 2019).\nIon-traps count with a virtual all-to-all connectivity that allows for any qubit to qubit interaction. Shortcomings can be attributed to the decrease of the speed and fidelity of 2 qubit gates as the number of ions in the chain increases though. As the size of the ion chain increases, its mass increases as does the average distance between ions. This in turn leads to a decrease in the coupling strength between arbitrary ions, causing a decrease in speed of 2 qubit gates. Fidelity decreases due to the increased susceptibility among the normal modes used to mediate the 2-qubit interaction to unwanted spectral crosstalk interaction, as well as to noise-induced heating in the system if the gates take longer.\nA way to circumvent this problem is to break up the long linear chain into smaller modules, and it is still the barrier many device manufacturers in this regime need to work on.\n\n\n\n\nProvider\nMax. Qubits\n\n\n\n\nIonQ\n23\n\n\nQuantinuum\n32\n\n\n\n\nMore on their current specs can be found in their sites or cloud provider sites:\n\nIonQ\nQuantinuum\n\nMore in detail information thanks to Xanadu.",
    "crumbs": [
      "Building a quantum computer",
      "Technology"
    ]
  },
  {
    "objectID": "parts/computers/technology.html#neutral-atoms",
    "href": "parts/computers/technology.html#neutral-atoms",
    "title": "Technology",
    "section": "Neutral atoms",
    "text": "Neutral atoms\nProposed around 2000, the basic concept lies in using atoms or neutral alkali metals like Rubidium (Rb) trapped in optical arrays. By laser cooling the atoms in an array to near absolute zero temperatures, traps using magnetic fields or lasers allows for rearrangement of the atoms within the lattice. Atom‚Äôs own structure represents the two level system we are looking for therefore a one-to-one mapping is done between the atom and the qubit we would like to manufacture.\n\n\n\n\nNeutral atoms\n\n\n\nSingle-qubit gate operations are achieved by driving atomic transitions using laser beams tightly focused on a single atom, or by microwaves, for which the targeted atom‚Äôs resonance needs to be shifted using magnetic fields or laser beams. Two-qubit gates would seem to be a hindrance for neutral atom qubits due to their weak interactions with each other; however, this problem is solved by exciting atoms to Rydberg states. A Rydberg atom exhibits a strong dipolar interaction and produces a phenomenon known as the Rydberg blockade, which prohibits more than one atom in a small volume from being simultaneously excited to a Rydberg state. This can be used to produce entanglement between two atoms using a three pulse sequence. The readout of the neutral atom array is typically done by taking a fluorescence image at the end of the computational process. It is performed such that each atom in the state \\(|0\\rangle\\) will appear bright, whereas atoms in the state \\(|1\\rangle\\) remain dark.\nThe arrangement of atoms in any type of 2D or even 3D structures makes problem mapping and qubit coupling flexible enough so that potentially any problem may fit into those devices. The main problem comes on the realization of two-qubit gates with high enough fidelity. Single-qubit operations reach 99.9% fidelity while two-qubit gates have been extensively studied boosting the initial 80% achieved in early 2016 to the reported 96.5% in 2019 (Levine et al. 2019). This is still an ongoing effort that limits the operability and universality of coding as most of the platforms require some kind of analog encoding as opposed to the logical abstraction others can provide.\n\n\n\n\nPasqal\n\n\n\nQubit coherence times are in the order of seconds, with and operation regime of \\(\\mu\\)seconds (approx. ratio \\(10^7\\)). They also count with the ability to operate simultaneously in different atom clusters, enabling operation overlapping as opposed to ion-traps.\n\n\n\n\nProvider\nMax. Qubits\n\n\n\n\nPasqal\n~300\n\n\nQuEra\n256\n\n\n\n\nSome specs on both hardware providers:\n\nPasqal\nQuEra\n\nAnd easy to read and in detail vision of this technology, once again, thanks to Xanadu.\n\n\n\n\nCirac, Juan I, and Peter Zoller. 1995. ‚ÄúQuantum Computations with Cold Trapped Ions.‚Äù Physical Review Letters 74 (20): 4091.\n\n\nCrain, Stephen, Clinton Cahall, Geert Vrijsen, Emma E Wollman, Matthew D Shaw, Varun B Verma, Sae Woo Nam, and Jungsang Kim. 2019. ‚ÄúHigh-Speed Low-Crosstalk Detection of a 171Yb+ Qubit Using Superconducting Nanowire Single Photon Detectors.‚Äù Communications Physics 2 (1): 97.\n\n\nLevine, Harry, Alexander Keesling, Giulia Semeghini, Ahmed Omran, Tout T Wang, Sepehr Ebadi, Hannes Bernien, et al. 2019. ‚ÄúParallel Implementation of High-Fidelity Multiqubit Gates with Neutral Atoms.‚Äù Physical Review Letters 123 (17): 170503.\n\n\nMyerson, AH, DJ Szwer, SC Webster, DTC Allcock, MJ Curtis, G Imreh, JA Sherman, DN Stacey, AM Steane, and DM Lucas. 2008. ‚ÄúHigh-Fidelity Readout of Trapped-Ion Qubits.‚Äù Physical Review Letters 100 (20): 200502.",
    "crumbs": [
      "Building a quantum computer",
      "Technology"
    ]
  },
  {
    "objectID": "parts/computers/machinetypes.html",
    "href": "parts/computers/machinetypes.html",
    "title": "Machine types",
    "section": "",
    "text": "Analog devices\nWe have talked about how the hardware works but not all Quantum Computers work in the same way. Just talking about pure quantum computers three main types of computers can be found.\nLike in the very beginning of computers, managing analog signals is the natural way to start when trying to domesticate physical phenomena to reproduce a particular set of steps. There do exist machines with well characterized qubits but requiring a specific way to interact with them. This is the case of neutral atom platforms, a Hamiltonian is provided that acts on the system and our duty is to define the signals that will drive the system towards the solution of our problem. These atoms are well defined qubits but manipulating them according to the mathematical framework can be challenging, therefore it is easier (in some sense) to drive the whole system by signal manipulation (hence analog computation).\nThe Hamiltonian on those devices looks as follows,\n\\[\n\\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | 0_j \\rangle  \\langle 1_j | + e^{-i \\phi_j(t) } | 1_j \\rangle  \\langle 0_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k,\n\\]\nwhere \\(|0_i\\rangle\\), \\(|1_i\\rangle\\), and \\(\\hat{n}_i = 0|0_i\\rangle\\langle0_i|+1|1_i\\rangle\\langle1_i|\\) refer to qubits \\(i\\) position for a given space. Defining algorithms requires manipulating the time-traces of the Hamiltonian parameters \\(\\Omega_i(t)\\), \\(\\phi_i(t)\\), and \\(\\Delta_i(t)\\). The Rabi term \\(\\Omega\\) and detuning \\(\\Delta\\) introduce energy scales that compete with the geometrically controlled scale \\(V_{ij}\\).\nThese machines natively solve a mathematical problem called, maximum independent set. Each atom has a blockade radius that prevents to atoms (qubits) being active at the same time (both being \\(|1\\rangle\\)). If we are able to encode our problem, the machine could without effort compute the most efficient points in a map where one should place specific assets based on their surroundings. More on about this on QuEra‚Äôs documentation site\nLook at this reference on how to interact with QuEra devices using Amazon Braket service and their SDK. It is easier than it looks but one needs to definitely know how to translate the problem to be solved to that formulation. These devices are often limited to a set of mathematical problems that requires users to think how their actual business problem may fit into those setups. As an example, here is a candidate problem on where to place antennas in Boston to minimize the cost but maximize coverage.\nMost likely, as it has happened with the rest of the machines, they will grow into the direction of digitized operation. A hint on previously mentioned native gates: defining a set of parameters that translated our device Hamiltonian to the gates we would like to use, is part of the magic many hardware providers perform through programming frameworks so that we don‚Äôt have to worry too much about it.",
    "crumbs": [
      "Building a quantum computer",
      "Machine types"
    ]
  },
  {
    "objectID": "parts/computers/machinetypes.html#analog-devices",
    "href": "parts/computers/machinetypes.html#analog-devices",
    "title": "Machine types",
    "section": "",
    "text": "Boston Antenna placement\n\n\n\n\nExample for above picture\nGeneral on MIS for neutral atoms: https://arxiv.org/pdf/2109.03517.pdf",
    "crumbs": [
      "Building a quantum computer",
      "Machine types"
    ]
  },
  {
    "objectID": "parts/computers/machinetypes.html#quantum-annealers",
    "href": "parts/computers/machinetypes.html#quantum-annealers",
    "title": "Machine types",
    "section": "Quantum Annealers",
    "text": "Quantum Annealers\nIn 1998, Hideyoshi Nishimoru from Tokyo University demonstrated that quantum annealing could outperform classical annealing techniques used up to that moment for optimization and combinatorial tasks. Quantum Annealers work by starting the system at a know state and by performing little perturbations to the system provide the solution to a target state. Its universality has been proven\nAdiabatic quantum computing (AQC) is a model of computation that uses quantum mechanical processes operating under adiabatic conditions. As a form of universal quantum computation, AQC employs the principles of superposition, tunneling, and entanglement that manifest in quantum physical systems.\n\n\n\n\nAdiabatic evolution of ground state\n\n\n\nD-Wave, was one of the first ones to produce a commercially available quantum computer with thousands of qubits. A clear milestone in the path towards commercially making it viable.\nA big caveat of this machine, is that it can only work using the adiabatic evolution as the main process. This means we can only govern the inner workings of the machine up to a point. Annealers work in precise manner so they do not allow for the flexibility digitized computers do, making them closer to an analog machine with restricted programming ability.\nThese machines are able to solve a complex problem indeed. In general any Quadratic Unconstrained Binary Optimization (QUBO) problem fits into the general framework of using annealers to solve the minimum energy state for a Ising type of problem:\n\\[\nH = -\\sum_{\\langle i j \\rangle} J s_i s_j - \\sum_j h s_j.\n\\]\nWe will see this more in detail when covering the inner workings of annealers but, think that if your problem fits into this type of mathematical formulation, you may find an ally when it comes to Quantum Annealers.",
    "crumbs": [
      "Building a quantum computer",
      "Machine types"
    ]
  },
  {
    "objectID": "parts/computers/machinetypes.html#digital-quantum-computers",
    "href": "parts/computers/machinetypes.html#digital-quantum-computers",
    "title": "Machine types",
    "section": "Digital quantum computers",
    "text": "Digital quantum computers\nIn order to provide certain level of universality when it comes to operations, digitization of the interactions with the quantum computer and the states it encodes has become a critical path towards quantum device commercialization. Managing Hamiltonians is still necessary but the way in which these need to be introduced into the machine could be handled by atomic operations (logical gates) with which we can compose higher level operators or create more complex dynamics taking us closer to how classical computers operate, enabling incremental instruction addition and higher level abstractions.\nDigitized computers work by enabling a set of digitized operations so that we can implement our routines. The initial state of the system would still be \\(|00...0\\rangle\\) so if we would like to transform this state into \\(|11..1\\rangle\\) we should find the Hamiltonian that does it.\nA not operation, like in classical computers, is one of the basic actions: \\[\nX^{\\otimes n} |0\\rangle^{\\otimes n} = |1\\rangle^{\\otimes n}\n\\]\nA simple composition of \\(X\\) (not) operation on each qubit. Therefore, we could express it in a pictorial way:\n\n\n\n\n\\(\\sigma_x\\) circuit\n\n\n\nThat way it is quite simple to understand what are the atomic operations required and have a programming language that abstracts us from signals and pulses.\nAs an example, a unitary transformation characterized by \\(U = Z_1 \\otimes Z_2\\) leads to a simple implementation\nOPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[2];\nrz(pi/2) q[0];\nrz(pi/2) q[1];\n\n\n\n\n\\(\\sigma_z\\) circuit\n\n\n\nThis approach makes programming these machines really close to the way in which classical devices were programmed in the early days.\nWe should pay attention though that this logical framework is often complicated to represent by physical means, therefore we will see some discrepancies when we start looking into what are called native gates. This will become clear when we start with our exercises against real hardware. Let‚Äôs keep the joy of playing with quantum simulators for now.",
    "crumbs": [
      "Building a quantum computer",
      "Machine types"
    ]
  },
  {
    "objectID": "parts/computers/serviceproviders.html",
    "href": "parts/computers/serviceproviders.html",
    "title": "Service providers",
    "section": "",
    "text": "Direct service providers\nMost of these machines cannot be purchased; or their cost would be way beyond any potential return of investment. They are quite expensive and require active maintenance so, lucky for us, we do count with the ability to interact with remote machines from our workstations. That way we can rent their usage and let others do the nasty work of maintenance. Most hardware providers offer their quantum computing machines as a service, so we can ask for computation time and send our circuits/algorithms to be executed on those. This was really common for Universities and research institutions when requesting time on a supercomputing or HPC resource but since the creation of the cloud it is also a well extended practice between data and analytics departments where ephemeral resources may make sense to be used due to the experimental nature of a given initiative.\nWe will guide on how these services can be enabled from players providing themselves the service as well as cloud providers where a wider variety of machines can be found.",
    "crumbs": [
      "Building a quantum computer",
      "Service providers"
    ]
  },
  {
    "objectID": "parts/computers/serviceproviders.html#direct-service-providers",
    "href": "parts/computers/serviceproviders.html#direct-service-providers",
    "title": "Service providers",
    "section": "",
    "text": "D-Wave\nD-Wave is known to be one of the first companies to make their quantum computers commercially available (2011). This Canadian niche player built quantum annealing machines so that people could‚Ä¶ buy them? Well probably that was part of their intention, but these are big expensive machines yet to prove their usefulness. Luckily in 2018 they released their cloud solution DWave Leap.\nTheir cloud access allows some free time on these machines so that users can evaluate their usefulness and advantage to solve specific problems.\n\n\n\n\nDWave Leap\n\n\n\nThe dashboard offers information about the remaining available usage time and there are options to open a browser based Integrated Development Environment (IDE) or access the documentation for use cases that may help get started with this service.\nWe already discussed that Quantum Annealers are a different type of beast, so they might require different ways to instruct what to do. That is why DWave had to leverage also Python based Software Development Kits so that people could interact with their machines (exclusively).\nOcean software stack\nBy attaching a GitHub account the initial 20 min. access is extended to a monthly time allowance where their purely quantum devices as well as hybrid solvers will be available.\n\n\n\n\nDWave devices\n\n\n\n\n\nIBM\nIBM has been involved since the early days in the development of quantum computers. Superconducting chips are at the core of what they can provide, and probably you have already seen some images on how their machines look like, so now you know what is inside this huge cylinder.\n\n\n\n\nIBM System One\n\n\n\nIt is said that IBM representatives asked at a conference how many of the attendees would actually interact with a quantum computing service to send their experiments if IBM would allow for such access. Apparently a huge amount of people raised their hands and that gave birth to IBM‚Äôs Quantum Computing platform https://www.ibm.com/quantum) and the framework that enabled the communication and experiment implementation, Qiskit.\n\n\n\n\nIBM Quantum\n\n\n\nWe could either use online resources available there, such as the Quantum Lab (a Jupyter based IDE) or get the API token to interact from our local machine by means of Qiskit. Same devices will be available for our experiments in both cases.\n\n\n\n\nIBM devices",
    "crumbs": [
      "Building a quantum computer",
      "Service providers"
    ]
  },
  {
    "objectID": "parts/computers/serviceproviders.html#cloud-hosted-services",
    "href": "parts/computers/serviceproviders.html#cloud-hosted-services",
    "title": "Service providers",
    "section": "Cloud hosted services",
    "text": "Cloud hosted services\nNot all companies have the ability to develop and maintain an online customer facing service as their focus may be more on the hardware development side, and they could benefit from partnerships where this is done by a third party. Cloud providers already aware of this, decided to step in and create a service so that others could host their quantum computing services.\n\nAmazon Braket\nAWS created a service called Amazon Braket so that people already using their cloud services could simply add quantum computing resources as an extra to their current stack. It offers similar experience to IBM‚Äôs or DWave, but the main benefit is the access to devices other than IBM‚Äôs or DWave‚Äôs.\n\n\n\n\nAWS devices\n\n\n\nOne can use their Software Development Kit (Braket SDK) which could be necessary for some devices not providing digitized gates but in general, due to the agreement on digitized instructions there it does exist an integration between both languages Amazon Braket SDK and IBM‚Äôs Qiskit.\n\n\nMicrosoft Azure\nSimilarly, Azure created a service that provides access to a set of devices some of them only being accessible in this platform (Quantinuum for example). Quantum Workspaces is the name, and it also offers a Jupyter based IDE for online experimentation.\n\n\n\n\nAzure devices\n\n\n\nMicrosoft created their own quantum computing framework called Q# but given the maturity of Qiskit, plugins do exist so that programmers won‚Äôt need to switch frameworks.\n\n\nDirect providers\nSome companies, like IonQ, do provide direct access to their simulators, emulators and devices via their cloud hosted service. This is the case of IonQ‚Äôs Cloud service. Anyone can sign up and request access to the simulators and QPUs available there.\n\n\n\n\nIonQ Cloud",
    "crumbs": [
      "Building a quantum computer",
      "Service providers"
    ]
  },
  {
    "objectID": "parts/computers/serviceproviders.html#third-party-providers",
    "href": "parts/computers/serviceproviders.html#third-party-providers",
    "title": "Service providers",
    "section": "Third party providers",
    "text": "Third party providers\nThere do exist some intermediary providers that position themselves between the hardware access and the developer experience. Definitely interesting to look at their offering as it evolves:\n\nStrangeworks\nqBraid",
    "crumbs": [
      "Building a quantum computer",
      "Service providers"
    ]
  },
  {
    "objectID": "parts/computers/currentoffering.html",
    "href": "parts/computers/currentoffering.html",
    "title": "Current offering",
    "section": "",
    "text": "Hardware based implementations\nThis is a tricky one, even though we love working with quantum computers, the key aspect is being able to solve efficiently a given problem. And, at this stage, there are many competitors doing a great job at solving problems without the need for quantum computers, and it is important that while this field evolves we make the most out of their colleagues. All those, quantum-inspired and quantum-adjacent technologies.\nFrom this family we have focused until now into the last bit, the Noisy Intermediate-Scale Quantum (NISQ) bit, the one related to actual quantum hardware but that does not mean those techniques and devices inspired by the challenges quantum mechanical systems pose are less than the actual hardware. In fact, one of the main problems to claim quantum advantage is the constant improvement and refinement of classical devices solving the same problems.\nWe highly recommend looking into classical and quantum-inspired solutions before jumping into the complexities of dealing with quantum hardware. There are really interesting results when it comes to classically emulating this formalism in the range of 10s to 100s of qubits and also hybrid approaches benefiting from specific aspects of the quantum domain, but heavily relying on classical processes (like Shor‚Äôs algorithm in fact).\nYou have been warned!\nBefore we enter into more cumbersome and obscure techniques, lets understand the context in which we are trying to use Quantum Computing to outperform classical means. It is not a fair comparison as we count with almost 70 years of development in the classical regime while quantum computers even though have been used for almost 25 years since the first realization of the qubit, might require some extra work until a similar status of maturity and confidence is reached.\nFollowing section will try to make the reader conscious about some of the issues they might face and how to tackle them, with a particular interest on Digital Quantum Computers.",
    "crumbs": [
      "Building a quantum computer",
      "Current offering"
    ]
  },
  {
    "objectID": "parts/computers/currentoffering.html#hardware-based-implementations",
    "href": "parts/computers/currentoffering.html#hardware-based-implementations",
    "title": "Current offering",
    "section": "",
    "text": "Quantum devices\nWe have seen many different devices exist but, even between the ones that are based on same technology we will find discrepancies on how they implement their operations. When this operations are fully parameterized we call them Gates but even though engineering makes a substantial effort bridging the gap between theoretical framework and physical reality, we might need to make our part as well.\n\nCoupling maps\nCoupling map refers to the connectivity between qubits. Most of our problems will be mapped to those qubits and we will need to define the strength of the action with respect to neighboring qubits. This ability to encode the interactions is reflected in the physical connection between the qubits on a given device and it is called the coupling map.\nAs an example, this is the coupling map of Rigetti:\n\n\n\nRigetti Aspen topology\n\n\nAnd this one belongs to IonQ‚Äôs Aria:\n\n\n\nIonQ Aria topology\n\n\nSeems like ino-traps may be a better fit to combinatorial optimization problems as they already count with all-to-all connectivity, but they lack the scale of superconducting devices. So, can we make anything to virtually connect those qubits on Rigetti‚Äôs device all-to-all?\nSWAP gates\nThe SWAP gate affects two qubits by interchanging their state, such that\n\\[\nSWAP|\\phi\\rangle|\\psi\\rangle = |\\psi\\rangle|\\phi\\rangle,\n\\]\nand its matrix form looks as follows\n\\[\nSWAP = \\left[\n\\begin{array}{cccc}\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{array}\n\\right].\n\\]\nBy iteratively applying this gates we can come up with a logical all-to-all connectivity even on sparsely connected devices. Swap strategies are quite common in the literature in particular when using superconducting devices. Different approaches can be found in the literature, and we will see in practice how it ends up being on reality, but in 2022 (Weidenfeller et al. 2022) they showed how adding interchanging SWAP layers produces an virtual all to all connectivity with minimal depth increase.\n\n\n\nSwap strategy\n\n\n\n\n\nSwaping for full connectivity\n\n\nThey we will simply need to introduce an appropriate amount of SWAP gates when needed according to our target device coupling map. The downside of it is that our circuit depth will increase, more operations are added, but that is not bad, is it?\n\n\nNative gates\nOur logical framework for quantum computing lands into different devices. As we already mentioned when discussing different device technologies, the actuation over the qubits is performed in different ways:\n\nSuperconducting qubits use microwave pulses\nIon traps use lasers\nNeutral atoms use lasers as well, in a slightly different manner\n\nTherefore all operations need to find a translation that maps logical gates with the expected outcome of it, meaning a calibrated pulse needs to be found that renders the expected result. Following is the example of the Hadamard gate on a given qubit\n\n\n\nHadamard pulse\n\n\nA Gaussian shape pulse of 128 system cycle unit duration and an amplitude of 0.1. If this was the level required to work, probably less people would embrace quantum computing, therefore most companies offer an already calibrated set of operations that even though they are not the whole set of gates of the formalism, sets a basic and universal set of operations so that any logical circuit can be transform to those native gates.\nIf we access any of the IBM Quantum Computing devices we can see how they already show relevant information where we can encounter those natively accessible gates named as the basis gates\n\n\n\nIBM Perth information\n\n\n\nID is the identity operation\nX is the NOT gate and SX, the \\(\\sqrt{X}\\)\nRZ is the rotation over the \\(Z\\) axis given an angle \\(\\theta\\)\nCX is our only two-qubit gate and represents the CNOT\n\nThen, if we only have a CNOT gate how could we implement the SWAP gates we needed in order to create an all-to-all connected circuit? Tricky as it might be we need to find a way to decompose our logical gates into the gates we have available (Gokhale et al. 2021).\n\n\n\nTranspilation\nTranspilation refers to the systematic approach of changing a logical circuit to fit under the basis gates and coupling map for a given device. Reminds to the old compilation step needed in computer programs to fit a given architecture but in this case, given that still converts our source code in a different source-code, transpilation is the appropriate name.\nThese logical steps, once transpiled can be interpreted by the device knowing the type of pulse that needs to be sent to each qubit to represent the requested operation.\nIBM counts with one of the most mature transpilation modules out there and it is often used to translate the logical circuits to specifications for other devices. It is composed by different circuit passes focusing on fixing specific issues between logical circuit and physical device.\n\n\n\nPasses for circuit transpilation using Qiskit\n\n\nAt the end you will see the representation fo the pulsed schedule that is finally submitted to the deive following the architecture layer as in the image below.\n\n\n\nLayers from logical circuit to actual pulses\n\n\nMore on this can be found on IBM‚Äôs documentation\n\n\nNoise\nAnd if that wasn‚Äôt enough, we saw on previous exercise our quantum devices are far from perfect. Operations not always turn out as expected:\n\nMeasurement or Readout error\nOperation error rates\n\nAnd given the limited coupling ability and native gate translation, more operations than initially required need to be added to the final circuit.\n\n\n\nIBM Jakarta\n\n\nAll this goes against the effort we have put when trying to solve our problem accurately using quantum computers. But, there is people researching on how this effect can be minimized or suppressed, so let‚Äôs see a couple of examples. It is also relevant to clarify the lingo as it might get messy.\nError suppression\nError suppression aims to leverage knowledge about the system and its fundamental errors to suppress their effect when someone runs a given circuit on those devices. It is often found at a fundamental level, really close o the hardware itself and should be easy to abstract the final user from these actions as they mostly require little knowledge about the executing circuit.\nA clear example of this techniques is Dynamical Decoupling. A techniques that introduces operations when qubits are idling so that they do not get affected by the surrounding qubtis and operations taking place.\n\n\n\nPulse scheme for dynamical decoupling\n\n\nDerivative Removal by Adiabatic Gate (DRAG) as an additional example, adds a component to the standard pulse shape to reduce qubits entering states higher than the 0 and 1 states we use for calculations. These techniques aim to fix fundamental issues related to the physical implementation.\nError mitigation\nThese techniques try to diminish the effect of noise during the execution by compensating for the systematic issues of the device itself. We could statistically characterize the systematic error upon redout and compensate for it after execution of the circuit.\n\n\n\nRedout error\n\n\nOr when expectation value is obtained, characterize the noise level and extrapolate the value we would have obtained in absence of noise for a given device.\n\n\n\nZero noise extrapolation (ZNE)\n\n\nSimple actions like layout selection, trying to select those qubits with less error on them or surrounding qubits might be simple and powerful enough for small circuits but it gets challenging on real use cases where depth and connectivity increase significantly.\nError correction\nError correction refers to the ultimate goal of many quantum computing companies, in particular hardware providers, where a logical implementation using redundant physical actions may lead to fault-tolerant device. the trick here is that our qubits will be a logical representation of what we have seen until now\n\\[\n|0\\rangle_L = |000000000\\rangle\n\\]\nAnd therefore, operations should also be modified to represent the actions on all physical qubits behind our logical actions. Below example is one of the canonical examples of error correcting codes designed by Peter Shor.\n\n\n\nShor‚Äôs error code\n\n\nFault Tolerant Quantum Computing would be the ideal scenario where a final user would only care about the logical implementation and the machine would deal with redundancy to fix errors and return the actual execution of the code in absence of noise. Sadly, we are still far from this future as it requires between hundreds and thousands of physical qubits to implement single logical qubits, increasing the scale up to million qubits needed for meaningful computation (see Google‚Äôs journey map).\nTherefore, we need to invest some time on manual error fixing and mitigation. Even though these techniques may sound complex, current status of frameworks such as Qiskit may help bridge the gap.\n\n\nAdditional means\nWell, I hope this wasn‚Äôt too intense. We got down to the inner workings of available Quantum Services and listed some of the impediments we might face when moving to actual devices. We did focus on Digital Quantum Computers being the ones that allow to move beyond the service offered by Quantum Annealers but does not require so much understanding as Analog Quantum Computers.\nBeing aware of the techniques that can be used we also showed how easy it is to implement those on actual devices on IBM‚Äôs Qiskit Runtime. Other cloud providers may enable other devices but will require additional knowledge on how to implement those techniques. We can benefit of some of the methods made available by Unitary Fund‚Äôs open-source community or niche players like Q-Ctrl:\n\nMitiq\nFire Opal\nSuperstaq\n\nMost likely quantum computing service providers will increase the abstraction making easier to implement algorithms in real hardware but for the moment, some work still needs to be done on our end as we saw. Let‚Äôs stick to simulators and emulators for now.\n\n\n\n\nGokhale, Pranav, Teague Tomesh, Martin Suchara, and Frederic T. Chong. 2021. ‚ÄúFaster and More Reliable Quantum SWAPs via Native Gates.‚Äù https://arxiv.org/abs/2109.13199.\n\n\nWeidenfeller, Johannes, Lucia C. Valor, Julien Gacon, Caroline Tornow, Luciano Bello, Stefan Woerner, and Daniel J. Egger. 2022. ‚ÄúScaling of the Quantum Approximate Optimization Algorithm on Superconducting Qubit Based Hardware.‚Äù Quantum 6 (December): 870. https://doi.org/10.22331/q-2022-12-07-870.",
    "crumbs": [
      "Building a quantum computer",
      "Current offering"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chuang, Isaac L, Neil Gershenfeld, and Mark Kubinec. 1998.\n‚ÄúExperimental Implementation of Fast Quantum Searching.‚Äù\nPhysical Review Letters 80 (15): 3408.\n\n\nCirac, Juan I, and Peter Zoller. 1995. ‚ÄúQuantum Computations with\nCold Trapped Ions.‚Äù Physical Review Letters 74 (20):\n4091.\n\n\nCrain, Stephen, Clinton Cahall, Geert Vrijsen, Emma E Wollman, Matthew D\nShaw, Varun B Verma, Sae Woo Nam, and Jungsang Kim. 2019.\n‚ÄúHigh-Speed Low-Crosstalk Detection of a 171Yb+ Qubit Using\nSuperconducting Nanowire Single Photon Detectors.‚Äù\nCommunications Physics 2 (1): 97.\n\n\nDiVincenzo, David P. 1997. ‚ÄúTopics in Quantum Computers.‚Äù\nIn Mesoscopic Electron Transport, 657‚Äì77. Springer.\n\n\nGokhale, Pranav, Teague Tomesh, Martin Suchara, and Frederic T. Chong.\n2021. ‚ÄúFaster and More Reliable Quantum SWAPs via Native\nGates.‚Äù https://arxiv.org/abs/2109.13199.\n\n\nKoch, Jens, Terri M Yu, Jay Gambetta, Andrew A Houck, David I Schuster,\nJohannes Majer, Alexandre Blais, Michel H Devoret, Steven M Girvin, and\nRobert J Schoelkopf. 2007. ‚ÄúCharge-Insensitive Qubit Design\nDerived from the Cooper Pair Box.‚Äù Physical Review A‚ÄîAtomic,\nMolecular, and Optical Physics 76 (4): 042319.\n\n\nLevine, Harry, Alexander Keesling, Giulia Semeghini, Ahmed Omran, Tout T\nWang, Sepehr Ebadi, Hannes Bernien, et al. 2019. ‚ÄúParallel\nImplementation of High-Fidelity Multiqubit Gates with Neutral\nAtoms.‚Äù Physical Review Letters 123 (17): 170503.\n\n\nMyerson, AH, DJ Szwer, SC Webster, DTC Allcock, MJ Curtis, G Imreh, JA\nSherman, DN Stacey, AM Steane, and DM Lucas. 2008. ‚ÄúHigh-Fidelity\nReadout of Trapped-Ion Qubits.‚Äù Physical Review Letters\n100 (20): 200502.\n\n\nNakamura, Y, Yu A Pashkin, and Jaw Shen Tsai. 2001. ‚ÄúRabi\nOscillations in a Josephson-Junction Charge Two-Level System.‚Äù\nPhysical Review Letters 87 (24): 246601.\n\n\nShor, Peter W. 1994. ‚ÄúAlgorithms for Quantum Computation: Discrete\nLogarithms and Factoring.‚Äù In Proceedings 35th Annual\nSymposium on Foundations of Computer Science, 124‚Äì34. Ieee.\n\n\nWeidenfeller, Johannes, Lucia C. Valor, Julien Gacon, Caroline Tornow,\nLuciano Bello, Stefan Woerner, and Daniel J. Egger. 2022. ‚ÄúScaling\nof the Quantum Approximate Optimization Algorithm on Superconducting\nQubit Based Hardware.‚Äù Quantum 6 (December): 870. https://doi.org/10.22331/q-2022-12-07-870.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "libraries.html",
    "href": "libraries.html",
    "title": "Appendix A ‚Äî Software packages",
    "section": "",
    "text": "QuTip: Quantum Toolbox for simulating the dynamics of quantum systems.\nQiskit: IBM‚Äôs development kit, the indisputable standard for gate-based quantum software development.\nOcean SDK: D-Wave proprietary SDK. Really useful for problem posing and creating the first instances of our particular instances before moving to annealers, gate-based devices or whatever might be the final solver.\nQuEra‚Äôs Bloqade for simulating Neutral Atom platforms both in Julia and Python\nAmazon Braket for simulation and sending jobs to Amazon Braket service.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>Software packages</span>"
    ]
  },
  {
    "objectID": "hybridsolvers.html",
    "href": "hybridsolvers.html",
    "title": "Appendix B ‚Äî Hybrid solvers",
    "section": "",
    "text": "B.1 Hybrid Annealers\nEven though we talked about Quantum Computers and how we can use them to solve specific problems, complex problems; what percentage of the problem is solved by each device (classical and quantum) depends on the specific problem we would like to solve.\nThink about Shor‚Äôs algorithm. It revolutionized the field and worried a couple of CSO/CISOs in the way. But it only changes one little step from the conventional Prime Factorization algorithm. Thanks to that tep there is a significant speedup in the algorithm taking it down from exponential order to polynomial one.\nA more detailed explanation can be found in IBM‚Äôs documentation but this type of hybrid approaches can really benefit from NISQ era hardware in other regimes like optimization.\nThis is the idea behind some of the services we found available today. On one side, we have the pioneers of the Quantum Computing cloud services, D-Wave and their LeapHybrid Solvers.\nTheir hybrid approach also allows to tackle beyond QUBO problems, like:\nDue to their change on pricing strategy, we can no longer mess around with their devices as much as we would like to so, an interesting alternative is the service provided by Quantagonia.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>¬† <span class='chapter-title'>Hybrid solvers</span>"
    ]
  },
  {
    "objectID": "hybridsolvers.html#hybrid-annealers",
    "href": "hybridsolvers.html#hybrid-annealers",
    "title": "Appendix B ‚Äî Hybrid solvers",
    "section": "",
    "text": "Non-linear problems\nConstrained Quadratic problems\nDiscrete Quadratic problems\n\n\n\n\n\nQuantagonia Dashboard",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>¬† <span class='chapter-title'>Hybrid solvers</span>"
    ]
  }
]