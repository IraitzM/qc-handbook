[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantum Computing Handbook",
    "section": "",
    "text": "Preface\nYou may wonder, another book about Quantum Computing? Well, by telling it from a different perspective it may help others grasp the idea but it will definitely help me better understand some of the concepts. Just by explaining things I found it is the best way to challenge ones knowledge about a field and master it. Also, it costs nothing so, no harm done.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Quantum Computing Handbook",
    "section": "About me",
    "text": "About me\nMi name is Iraitz Montalbán, Computer Scientist by background I started in the field of Quantum Computing by chance, while doing an internship in 2010 there were some guys doing something called quantum computing, which was a mathematical framework back then. I kept my interest in the field and ended up doing a masters on Quantum Computing Technologies at UPM and working with some startups in the field.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Well, quantum computing. Really trendy topic. Fancy as it might be there are some really cool things we can learn from trying to challenge the status quo. Let’s see if we can get our heads around what quantum computing is and how to work with it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "theory.html",
    "href": "theory.html",
    "title": "2  Getting started",
    "section": "",
    "text": "2.1 Measurement\nWhat is quantum computing? Well, nothing but a new paradigm to perform computation. It is based on the formalism of quantum physics and even though it might be challenging to grasp at first, just some basic linear algebra might help you understanding the basics. I will try to show it by examples in Python so that it is less challenging and more hands-on.\nClassical computing also embraces physics but at a much higher abstraction level. Boolean algebra made possible an universal set of operations to produce the algorithms we do use on a daily basis. Then, being able to manufacture bits as voltages made possible to build machines capable of following that algebra. The rest is history.\nThe main idea behind quantum computing is that, instead of working at a macroscopic level as we are used to, by using quantum states on some physical mean we could benefit from the effects inherent to quantum physics to perform computation in different ways. By leveraging the those effects some really complex calculations could be performed more efficiently. Superposition, interference and entanglement are the key to most of the speedups claimed in the literature, and we will try to understand how we can work with those.\nThe main concept leveraged by quantum computers is the ability to act over quantum states. A quantum state is no other thing than a mathematical description of the probability distribution for the potential outcome after performing a measurement upon a system. It sounds tricky.\nThink about it as a normed vector (vector of length 1). Let’s try with the most simple example, a coin. Well, the quantum version of a coin looks like:\n\\[\n|\\phi\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\n\\]\nbeing this the minimum representation of a quantum state: a unit norm vector \\(\\in \\mathbb{C}^2\\) whose physical realization is known as the qubit.\nThis means that \\(|\\alpha|^2+|\\beta|^2 = 1\\) as these are the two outcome probabilities that should add up to one. That way we know any potential outcome must be comprised by the basis we would be using to identify our basic states. This is relevant as when it comes to quantum computers, our minimal unit will be expressed on its computational basis: \\[\n|0\\rangle = \\left[\n\\begin{array}{c}\n1 \\\\\n0\n\\end{array}\n\\right]\n\\quad\n|1\\rangle = \\left[\n\\begin{array}{c}\n0 \\\\\n1\n\\end{array}\n\\right]\n\\]\nTherefore previous state can be characterized in our qubit unit as:\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle = \\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\n\\]\nmeaning our quantum state’s potential outcomes are \\(|\\alpha|^2\\) for \\(|0\\rangle\\) and \\(|\\beta|^2\\) for \\(|1\\rangle\\). How do we know the actual outcome of our state? Projecting it over one of those states, so the complex conjugate of previous vectors can be used for that.\n\\[\n\\langle 0 | = \\left[\n\\begin{array}{cc}\n1 & 0\n\\end{array}\n\\right]\n\\quad\n\\langle 1 | = \\left[\n\\begin{array}{cc}\n0 & 1\n\\end{array}\n\\right]\n\\]\nso by projecting our state into this basis vectors we would obtain:\n\\[\n|\\langle 0 |\\psi\\rangle|^2 = \\left|\\left[\n\\begin{array}{cc}\n1 & 0\n\\end{array}\n\\right]\\left[\n\\begin{array}{c}\n\\alpha \\\\\n\\beta\n\\end{array}\n\\right]\\right|^2 = |\\alpha|^2\n\\]\nSo we don’t actually evaluate the state, but we use a basis vector to see “how close” our state is to this state that is part of our basis set.\nAnd here we found one of the first strange things about qubits in comparison to bits. Being 0 and 1 the basic states of a bit, its physical realization can only be in on of those states while qubits can be partially in more than one state creating a superposition of states.\nMeasuring quantum states is a necessary condition to extract information out of it, but by doing so we affect the system due to the collapse of the wave function. Observables (self-adjoint operators) are used to project the measurement of a given quantum state to one of its eigenvalues by using the closeness between quantum state and eigenvectors of the observable being used. The eigenvectors of the observable form an orthonormal basis for the Hilbert space, therefore each measure corresponds to a mapping to the eigenvectors comprising the basis.\nWe will see that a common observable used is the Pauli \\(\\sigma_z\\) matrix\n\\[\n\\sigma_z = \\left[\n\\begin{array}{cc}\n1 & 0 \\\\\n0 & -1\n\\end{array}\n\\right]\n\\]\nwhose decomposition is\n\\[\n\\sigma_z|0\\rangle = 1|0\\rangle \\rightarrow \\sigma_z|1\\rangle = -1|1\\rangle\n\\]\ntherefore, any potential measurement will be mapped to one of those two eigenvectors and its eigenvalue used as the outcome of the measurement. The basis set shown above is often known as the computational basis and it will become relevant when we move to actual implementations.\nFrom our previous state \\(|\\phi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle\\) and perform a measurement over the computational basis (\\(|0\\rangle,|1\\rangle\\)) where evidently the outcome would be \\(|0\\rangle\\) with \\(|\\alpha|^2\\) probability or \\(|1\\rangle\\) with \\(|\\beta|^2\\) probability. But more importantly, a single measurement, no matter how complex, entangled or superposed our state might be, will only be able to recover classical bits mapping two previously seen states (\\(|0\\rangle \\rightarrow 0\\) and \\(|1\\rangle \\rightarrow 1\\)).\nWhat happens after measurement is performed? Well, that is the trickiest part as the process of measuring obliges to our quantum state to position itself and make a choice. This means our quantum state after measurement will no longer be in a superposition state and will be the outcome of the previous measurement \\(|0\\rangle\\) for the remaining time period.\nIn order to fully grasp the statistics of the state we should find way to reproduce the state and perform enough measurements, so we can characterize its actual condition as much as we can out of the measurement statistics it presents. Measuring in the basis \\(\\{|0\\rangle, |1\\rangle\\}\\) (also called computational basis) may not be enough to capture the actual state. Therefore, a basis change is needed, but we will see that quantum devices only offer computational basis as the measuring basis. That means in certain cases we will need to rotate our qubits so that the basis change is artificially done.\nIf we would like to measure in the \\(\\{|+\\rangle, |-\\rangle\\}\\) basis then a rotation of \\(-\\pi / 2\\) in the Y axis will be needed. \\(\\{|i\\rangle, |-i\\rangle\\}\\) basis will require then a rotation over X axis of \\(\\pi / 2\\). That way we get to shift the reference point and measure according to our target axis.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting started</span>"
    ]
  },
  {
    "objectID": "theory.html#superposition",
    "href": "theory.html#superposition",
    "title": "2  Getting started",
    "section": "2.2 Superposition",
    "text": "2.2 Superposition\nThis is one of the trickiest things to get when first approaching quantum computing as it is not so intuitive from our macroscopic perspective. It is also often misunderstood, we will try to make it clear. This is an example of a superposed state\n\\[\n|\\phi\\rangle =\n\\alpha |0\\rangle +\n\\beta |1\\rangle.\n\\]\nThe state is a superposed, no question on that, but our ability to perceive it is limited by the measurement procedure itself. We need to project our quantum state into one of the two potential states we can obtain (\\(|0\\rangle\\) or \\(|1\\rangle\\)). Sadly, when measuring only classical bits can be obtained (0 or 1) into our conventional machines, so no probability amplitude, no phase… information gets lost in the measurement process.\nThe probability histogram is created after a sequence of quantum state creations and measurements we often call SHOTS.\n\n\n\n\nCoin toss\n\n\n\nFor a series of measurements we have seen \\(|0\\rangle\\) state 50.6% and \\(|1\\rangle\\) state 49.4%. Definitely, looks superposed to me. It is hardly perceived in the classical regime were every basis state will be interpreted as its complementary classical bit, but quantum state holds a lot of information more than this simple binary choice.\nIn fact, both \\(\\alpha\\) and \\(\\beta\\) are complex numbers, that is why bloch sphere renders a more in detail expression of the state of a qubit. Sadly for us this is something we will never perceive from a real device but helps while building the formalism or creating algorithms.\n\n\n\n\nBloch sphere\n\n\n\nQuantum states can therefore be expressed also as:\n\\[\n|\\phi\\rangle = \\cos (\\theta/2) |0\\rangle + e^{i\\phi} \\sin (\\theta/2)|1\\rangle\n\\]\nwhich represents the sphere coordinates on the surface of the bloch sphere. It is more evident in this case that rendering simple bits will actually remove most of the information contained in the states when operating with them in the quantum regime.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting started</span>"
    ]
  }
]