# Getting started

What is quantum computing? Well, nothing but a new paradigm to perform computation. It is based on the formalism of **quantum physics** and even though it might be challenging to grasp at first, just some basic linear algebra might help you understanding the basics. I will try to show it by examples in Python so that it is less challenging and more hands-on.

Classical computing also embraces physics but at a much higher abstraction level. [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra) made possible an universal set of operations to produce the algorithms we do use on a daily basis. Then, being able to manufacture bits as voltages made possible to build machines capable of following that algebra. The rest is history.

The main idea behind quantum computing is that, instead of working at a macroscopic level as we are used to, by using quantum states on some physical mean we could benefit from the effects inherent to quantum physics to perform computation in _different ways_. By leveraging the those effects some really complex calculations could be performed more efficiently. _Superposition_, _interference_ and _entanglement_ are the key to most of the speedups claimed in the literature, and we will try to understand how we can work with those.

This is part of the recent history of the field and future roadmap.
<figure markdown>
  ![QC timeline](assets/timeline.png)
</figure>

The main concept leveraged by quantum computers is the ability to act over quantum states. A quantum state is no other thing than a mathematical description of the probability distribution for the potential outcome after performing a measurement upon a system. It sounds tricky.

Think about it as a normed vector (vector of _length_ 1). Let's try with the most simple example, a coin. Well, the quantum version of a coin looks like:

$$
|\phi\rangle = \left[
\begin{array}{c}
\alpha \\
\beta
\end{array}
\right]
$$

being this the minimum representation of a quantum state: a unit norm vector $\in \mathbb{C}^2$ whose physical realization is known as the **qubit**.

This means that $|\alpha|^2+|\beta|^2 = 1$ as these are the two outcome probabilities that should add up to one. That way we know any potential outcome must be comprised by the basis we would be using to identify our basic states. This is relevant as when it comes to quantum computers, our minimal unit will be expressed on its computational basis:
$$
|0\rangle = \left[
\begin{array}{c}
1 \\
0
\end{array}
\right]
\quad
|1\rangle = \left[
\begin{array}{c}
0 \\
1
\end{array}
\right]
$$

Therefore previous state can be characterized in our qubit unit as:

$$
|\phi\rangle =
\alpha |0\rangle + 
\beta |1\rangle = \left[
\begin{array}{c}
\alpha \\
\beta
\end{array}
\right]
$$

meaning our quantum state's potential outcomes are $|\alpha|^2$ for $|0\rangle$ and $|\beta|^2$ for $|1\rangle$. How do we know the actual outcome of our state? Projecting it over one of those states, so the complex conjugate of previous vectors can be used for that.

$$
\langle 0 | = \left[
\begin{array}{cc}
1 & 0
\end{array}
\right]
\quad
\langle 1 | = \left[
\begin{array}{cc}
0 & 1
\end{array}
\right]
$$

so by projecting our state into this basis vectors we would obtain:

$$
|\langle 0 |\psi\rangle|^2 = \left|\left[
\begin{array}{cc}
1 & 0
\end{array}
\right]\left[
\begin{array}{c}
\alpha \\
\beta
\end{array}
\right]\right|^2 = |\alpha|^2
$$

So we don't actually evaluate the state, but we use a basis vector to see "how close" our state is to this state that is part of our basis set.

And here we found one of the first strange things about qubits in comparison to bits. Being 0 and 1 the basic states of a bit, its physical realization can only be in on of those states while qubits can be _partially_ in more than one state creating a **superposition** of states.

## Measurement

Measuring quantum states is a necessary condition to extract information out of it, but by doing so we affect the system due to the collapse of the wave function. **Observables** (self-adjoint operators) are used to project the measurement of a given quantum state to one of its eigenvalues by using the closeness between quantum state and eigenvectors of the observable being used. The eigenvectors of the observable form an orthonormal basis for the Hilbert space, therefore each measure corresponds to a mapping to the eigenvectors comprising the basis.

We will see that a common observable used is the Pauli $\sigma_z$ matrix

$$
\sigma_z = \left[
\begin{array}{cc}
1 & 0 \\
0 & -1
\end{array}
\right]
$$

whose decomposition is

$$
\sigma_z|0\rangle = 1|0\rangle \rightarrow \sigma_z|1\rangle = -1|1\rangle
$$

therefore, any potential measurement will be mapped to one of those two eigenvectors and its eigenvalue used as the outcome of the measurement. The basis set shown above is often known as the **computational basis** and it will become relevant when we move to actual implementations.

From our previous state $|\phi\rangle = \alpha |0\rangle + \beta |1\rangle$ and perform a measurement over the computational basis ($|0\rangle,|1\rangle$) where evidently the outcome would be $|0\rangle$ with $|\alpha|^2$ probability or $|1\rangle$ with $|\beta|^2$ probability. But more importantly, a single measurement, no matter how complex, entangled or superposed our state might be, will only be able to recover classical bits mapping two previously seen states ($|0\rangle \rightarrow 0$ and $|1\rangle \rightarrow 1$).

What happens after measurement is performed? Well, that is the trickiest part as the process of measuring obliges to our quantum state to position itself and make a choice. This means our quantum state after measurement will no longer be in a superposition state and will be the outcome of the previous measurement $|0\rangle$ for the remaining time period.

In order to fully grasp the statistics of the state we should find way to reproduce the state and perform enough measurements, so we can characterize its actual condition as much as we can out of the measurement statistics it presents. Measuring in the basis $\{|0\rangle, |1\rangle\}$ (also called computational basis) may not be enough to capture the actual state. Therefore, a basis change is needed, but we will see that quantum devices only offer computational basis as the measuring basis. That means in certain cases we will need to rotate our qubits so that the basis change is artificially done.

If we would like to measure in the $\{|+\rangle, |-\rangle\}$ basis then a rotation of $-\pi / 2$ in the Y axis will be needed. $\{|i\rangle, |-i\rangle\}$ basis will require then a rotation over X axis of $\pi / 2$. That way we get to shift the reference point and measure according to our target axis.

## Superposition

This is one of the trickiest things to get when first approaching quantum computing as it is not so intuitive from our macroscopic perspective. It is also often misunderstood, we will try to make it clear. This is an example of a superposed state

$$
|\phi\rangle =
\alpha |0\rangle + 
\beta |1\rangle.
$$

The state is a superposed, no question on that, but our ability to perceive it is limited by the measurement procedure itself. We need to project our quantum state into one of the two potential states we can obtain ($|0\rangle$ or $|1\rangle$). Sadly, when measuring only classical bits can be obtained (0 or 1) into our conventional machines, so no probability amplitude, no phase... information gets lost in the measurement process.

The _probability histogram_ is created after a sequence of quantum state creations and measurements we often call **SHOTS**.

<figure markdown>
![Coin toss](assets/cointoss.png)
</figure>

For a series of measurements we have seen $|0\rangle$ state 50.6% and $|1\rangle$ state 49.4%. Definitely, looks superposed to me. It is hardly perceived in the classical regime were every basis state will be interpreted as its complementary classical bit, but quantum state holds a lot of information more than this simple binary choice. 

In fact, both $\alpha$ and $\beta$ are complex numbers, that is why _bloch sphere_ renders a more in detail expression of the state of a qubit. Sadly for us this is something we will never perceive from a real device but helps while building the formalism or creating algorithms.

<figure markdown>
![Bloch sphere](assets/bloch.gif){ width=60% }
</figure>

Quantum states can therefore be expressed also as:

$$
|\phi\rangle = \cos (\theta/2) |0\rangle + e^{i\phi} \sin (\theta/2)|1\rangle
$$

which represents the sphere coordinates on the surface of the _bloch sphere_. It is more evident in this case that rendering simple bits will actually remove most of the information contained in the states when operating with them in the quantum regime.
